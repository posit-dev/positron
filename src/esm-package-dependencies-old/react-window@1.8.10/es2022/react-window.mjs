/* eslint-disable */
function Z() { return Z = Object.assign ? Object.assign.bind() : function (o) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var n in t) ({}).hasOwnProperty.call(t, n) && (o[n] = t[n]) } return o }, Z.apply(null, arguments) } function J(o) { if (o === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return o } function Q(o, e) { return Q = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, n) { return t.__proto__ = n, t }, Q(o, e) } function ee(o, e) { o.prototype = Object.create(e.prototype), o.prototype.constructor = o, Q(o, e) } import j from "../../memoize-one@5.2.1/es2022/memoize-one.mjs"; import { createElement as K, PureComponent as fe } from "../../react@19.2.4/es2022/react.mjs"; function te(o, e) { if (o == null) return {}; var t = {}; for (var n in o) if ({}.hasOwnProperty.call(o, n)) { if (e.indexOf(n) !== -1) continue; t[n] = o[n] } return t } var Te = typeof performance == "object" && typeof performance.now == "function", le = Te ? function () { return performance.now() } : function () { return Date.now() }; function X(o) { cancelAnimationFrame(o.id) } function he(o, e) { var t = le(); function n() { le() - t >= e ? o.call(null) : i.id = requestAnimationFrame(n) } var i = { id: requestAnimationFrame(n) }; return i } var ne = -1; function re(o) { if (o === void 0 && (o = !1), ne === -1 || o) { var e = document.createElement("div"), t = e.style; t.width = "50px", t.height = "50px", t.overflow = "scroll", document.body.appendChild(e), ne = e.offsetWidth - e.clientWidth, document.body.removeChild(e) } return ne } var $ = null; function Y(o) { if (o === void 0 && (o = !1), $ === null || o) { var e = document.createElement("div"), t = e.style; t.width = "50px", t.height = "50px", t.overflow = "scroll", t.direction = "rtl"; var n = document.createElement("div"), i = n.style; return i.width = "100px", i.height = "100px", e.appendChild(n), document.body.appendChild(e), e.scrollLeft > 0 ? $ = "positive-descending" : (e.scrollLeft = 1, e.scrollLeft === 0 ? $ = "negative" : $ = "positive-ascending"), document.body.removeChild(e), $ } return $ } var Re = 150, Oe = function (e) { var t = e.columnIndex, n = e.data, i = e.rowIndex; return i + ":" + t }; function me(o) { var e, t = o.getColumnOffset, n = o.getColumnStartIndexForOffset, i = o.getColumnStopIndexForStartIndex, s = o.getColumnWidth, l = o.getEstimatedTotalHeight, u = o.getEstimatedTotalWidth, c = o.getOffsetForColumnAndAlignment, v = o.getOffsetForRowAndAlignment, m = o.getRowHeight, w = o.getRowOffset, g = o.getRowStartIndexForOffset, T = o.getRowStopIndexForStartIndex, z = o.initInstanceProps, a = o.shouldResetStyleCacheOnItemSizeChange, h = o.validateProps; return e = (function (p) { ee(C, p); function C(y) { var r; return r = p.call(this, y) || this, r._instanceProps = z(r.props, J(r)), r._resetIsScrollingTimeoutId = null, r._outerRef = void 0, r.state = { instance: J(r), isScrolling: !1, horizontalScrollDirection: "forward", scrollLeft: typeof r.props.initialScrollLeft == "number" ? r.props.initialScrollLeft : 0, scrollTop: typeof r.props.initialScrollTop == "number" ? r.props.initialScrollTop : 0, scrollUpdateWasRequested: !1, verticalScrollDirection: "forward" }, r._callOnItemsRendered = void 0, r._callOnItemsRendered = j(function (f, d, S, x, I, R, b, _) { return r.props.onItemsRendered({ overscanColumnStartIndex: f, overscanColumnStopIndex: d, overscanRowStartIndex: S, overscanRowStopIndex: x, visibleColumnStartIndex: I, visibleColumnStopIndex: R, visibleRowStartIndex: b, visibleRowStopIndex: _ }) }), r._callOnScroll = void 0, r._callOnScroll = j(function (f, d, S, x, I) { return r.props.onScroll({ horizontalScrollDirection: S, scrollLeft: f, scrollTop: d, verticalScrollDirection: x, scrollUpdateWasRequested: I }) }), r._getItemStyle = void 0, r._getItemStyle = function (f, d) { var S = r.props, x = S.columnWidth, I = S.direction, R = S.rowHeight, b = r._getItemStyleCache(a && x, a && I, a && R), _ = f + ":" + d, W; if (b.hasOwnProperty(_)) W = b[_]; else { var E = t(r.props, d, r._instanceProps), O = I === "rtl"; b[_] = W = { position: "absolute", left: O ? void 0 : E, right: O ? E : void 0, top: w(r.props, f, r._instanceProps), height: m(r.props, f, r._instanceProps), width: s(r.props, d, r._instanceProps) } } return W }, r._getItemStyleCache = void 0, r._getItemStyleCache = j(function (f, d, S) { return {} }), r._onScroll = function (f) { var d = f.currentTarget, S = d.clientHeight, x = d.clientWidth, I = d.scrollLeft, R = d.scrollTop, b = d.scrollHeight, _ = d.scrollWidth; r.setState(function (W) { if (W.scrollLeft === I && W.scrollTop === R) return null; var E = r.props.direction, O = I; if (E === "rtl") switch (Y()) { case "negative": O = -I; break; case "positive-descending": O = _ - x - I; break }O = Math.max(0, Math.min(O, _ - x)); var N = Math.max(0, Math.min(R, b - S)); return { isScrolling: !0, horizontalScrollDirection: W.scrollLeft < I ? "forward" : "backward", scrollLeft: O, scrollTop: N, verticalScrollDirection: W.scrollTop < R ? "forward" : "backward", scrollUpdateWasRequested: !1 } }, r._resetIsScrollingDebounced) }, r._outerRefSetter = function (f) { var d = r.props.outerRef; r._outerRef = f, typeof d == "function" ? d(f) : d != null && typeof d == "object" && d.hasOwnProperty("current") && (d.current = f) }, r._resetIsScrollingDebounced = function () { r._resetIsScrollingTimeoutId !== null && X(r._resetIsScrollingTimeoutId), r._resetIsScrollingTimeoutId = he(r._resetIsScrolling, Re) }, r._resetIsScrolling = function () { r._resetIsScrollingTimeoutId = null, r.setState({ isScrolling: !1 }, function () { r._getItemStyleCache(-1) }) }, r } C.getDerivedStateFromProps = function (r, f) { return ze(r, f), h(r), null }; var M = C.prototype; return M.scrollTo = function (r) { var f = r.scrollLeft, d = r.scrollTop; f !== void 0 && (f = Math.max(0, f)), d !== void 0 && (d = Math.max(0, d)), this.setState(function (S) { return f === void 0 && (f = S.scrollLeft), d === void 0 && (d = S.scrollTop), S.scrollLeft === f && S.scrollTop === d ? null : { horizontalScrollDirection: S.scrollLeft < f ? "forward" : "backward", scrollLeft: f, scrollTop: d, scrollUpdateWasRequested: !0, verticalScrollDirection: S.scrollTop < d ? "forward" : "backward" } }, this._resetIsScrollingDebounced) }, M.scrollToItem = function (r) { var f = r.align, d = f === void 0 ? "auto" : f, S = r.columnIndex, x = r.rowIndex, I = this.props, R = I.columnCount, b = I.height, _ = I.rowCount, W = I.width, E = this.state, O = E.scrollLeft, N = E.scrollTop, A = re(); S !== void 0 && (S = Math.max(0, Math.min(S, R - 1))), x !== void 0 && (x = Math.max(0, Math.min(x, _ - 1))); var H = l(this.props, this._instanceProps), F = u(this.props, this._instanceProps), L = F > W ? A : 0, k = H > b ? A : 0; this.scrollTo({ scrollLeft: S !== void 0 ? c(this.props, S, d, O, this._instanceProps, k) : O, scrollTop: x !== void 0 ? v(this.props, x, d, N, this._instanceProps, L) : N }) }, M.componentDidMount = function () { var r = this.props, f = r.initialScrollLeft, d = r.initialScrollTop; if (this._outerRef != null) { var S = this._outerRef; typeof f == "number" && (S.scrollLeft = f), typeof d == "number" && (S.scrollTop = d) } this._callPropsCallbacks() }, M.componentDidUpdate = function () { var r = this.props.direction, f = this.state, d = f.scrollLeft, S = f.scrollTop, x = f.scrollUpdateWasRequested; if (x && this._outerRef != null) { var I = this._outerRef; if (r === "rtl") switch (Y()) { case "negative": I.scrollLeft = -d; break; case "positive-ascending": I.scrollLeft = d; break; default: var R = I.clientWidth, b = I.scrollWidth; I.scrollLeft = b - R - d; break } else I.scrollLeft = Math.max(0, d); I.scrollTop = Math.max(0, S) } this._callPropsCallbacks() }, M.componentWillUnmount = function () { this._resetIsScrollingTimeoutId !== null && X(this._resetIsScrollingTimeoutId) }, M.render = function () { var r = this.props, f = r.children, d = r.className, S = r.columnCount, x = r.direction, I = r.height, R = r.innerRef, b = r.innerElementType, _ = r.innerTagName, W = r.itemData, E = r.itemKey, O = E === void 0 ? Oe : E, N = r.outerElementType, A = r.outerTagName, H = r.rowCount, F = r.style, L = r.useIsScrolling, k = r.width, U = this.state.isScrolling, D = this._getHorizontalRangeToRender(), V = D[0], Ie = D[1], ie = this._getVerticalRangeToRender(), Ce = ie[0], Me = ie[1], ae = []; if (S > 0 && H) for (var B = Ce; B <= Me; B++)for (var G = V; G <= Ie; G++)ae.push(K(f, { columnIndex: G, data: W, isScrolling: L ? U : void 0, key: O({ columnIndex: G, data: W, rowIndex: B }), rowIndex: B, style: this._getItemStyle(B, G) })); var xe = l(this.props, this._instanceProps), ye = u(this.props, this._instanceProps); return K(N || A || "div", { className: d, onScroll: this._onScroll, ref: this._outerRefSetter, style: Z({ position: "relative", height: I, width: k, overflow: "auto", WebkitOverflowScrolling: "touch", willChange: "transform", direction: x }, F) }, K(b || _ || "div", { children: ae, ref: R, style: { height: xe, pointerEvents: U ? "none" : void 0, width: ye } })) }, M._callPropsCallbacks = function () { var r = this.props, f = r.columnCount, d = r.onItemsRendered, S = r.onScroll, x = r.rowCount; if (typeof d == "function" && f > 0 && x > 0) { var I = this._getHorizontalRangeToRender(), R = I[0], b = I[1], _ = I[2], W = I[3], E = this._getVerticalRangeToRender(), O = E[0], N = E[1], A = E[2], H = E[3]; this._callOnItemsRendered(R, b, O, N, _, W, A, H) } if (typeof S == "function") { var F = this.state, L = F.horizontalScrollDirection, k = F.scrollLeft, U = F.scrollTop, D = F.scrollUpdateWasRequested, V = F.verticalScrollDirection; this._callOnScroll(k, U, L, V, D) } }, M._getHorizontalRangeToRender = function () { var r = this.props, f = r.columnCount, d = r.overscanColumnCount, S = r.overscanColumnsCount, x = r.overscanCount, I = r.rowCount, R = this.state, b = R.horizontalScrollDirection, _ = R.isScrolling, W = R.scrollLeft, E = d || S || x || 1; if (f === 0 || I === 0) return [0, 0, 0, 0]; var O = n(this.props, W, this._instanceProps), N = i(this.props, O, W, this._instanceProps), A = !_ || b === "backward" ? Math.max(1, E) : 1, H = !_ || b === "forward" ? Math.max(1, E) : 1; return [Math.max(0, O - A), Math.max(0, Math.min(f - 1, N + H)), O, N] }, M._getVerticalRangeToRender = function () { var r = this.props, f = r.columnCount, d = r.overscanCount, S = r.overscanRowCount, x = r.overscanRowsCount, I = r.rowCount, R = this.state, b = R.isScrolling, _ = R.verticalScrollDirection, W = R.scrollTop, E = S || x || d || 1; if (f === 0 || I === 0) return [0, 0, 0, 0]; var O = g(this.props, W, this._instanceProps), N = T(this.props, O, W, this._instanceProps), A = !b || _ === "backward" ? Math.max(1, E) : 1, H = !b || _ === "forward" ? Math.max(1, E) : 1; return [Math.max(0, O - A), Math.max(0, Math.min(I - 1, N + H)), O, N] }, C })(fe), e.defaultProps = { direction: "ltr", itemData: void 0, useIsScrolling: !1 }, e } var ze = function (e, t) { var n = e.children, i = e.direction, s = e.height, l = e.innerTagName, u = e.outerTagName, c = e.overscanColumnsCount, v = e.overscanCount, m = e.overscanRowsCount, w = e.width, g = t.instance }, se = 50, pe = function (e, t) { var n = e.rowCount, i = t.rowMetadataMap, s = t.estimatedRowHeight, l = t.lastMeasuredRowIndex, u = 0; if (l >= n && (l = n - 1), l >= 0) { var c = i[l]; u = c.offset + c.size } var v = n - l - 1, m = v * s; return u + m }, ve = function (e, t) { var n = e.columnCount, i = t.columnMetadataMap, s = t.estimatedColumnWidth, l = t.lastMeasuredColumnIndex, u = 0; if (l >= n && (l = n - 1), l >= 0) { var c = i[l]; u = c.offset + c.size } var v = n - l - 1, m = v * s; return u + m }, P = function (e, t, n, i) { var s, l, u; if (e === "column" ? (s = i.columnMetadataMap, l = t.columnWidth, u = i.lastMeasuredColumnIndex) : (s = i.rowMetadataMap, l = t.rowHeight, u = i.lastMeasuredRowIndex), n > u) { var c = 0; if (u >= 0) { var v = s[u]; c = v.offset + v.size } for (var m = u + 1; m <= n; m++) { var w = l(m); s[m] = { offset: c, size: w }, c += w } e === "column" ? i.lastMeasuredColumnIndex = n : i.lastMeasuredRowIndex = n } return s[n] }, ue = function (e, t, n, i) { var s, l; e === "column" ? (s = n.columnMetadataMap, l = n.lastMeasuredColumnIndex) : (s = n.rowMetadataMap, l = n.lastMeasuredRowIndex); var u = l > 0 ? s[l].offset : 0; return u >= i ? ge(e, t, n, l, 0, i) : be(e, t, n, Math.max(0, l), i) }, ge = function (e, t, n, i, s, l) { for (; s <= i;) { var u = s + Math.floor((i - s) / 2), c = P(e, t, u, n).offset; if (c === l) return u; c < l ? s = u + 1 : c > l && (i = u - 1) } return s > 0 ? s - 1 : 0 }, be = function (e, t, n, i, s) { for (var l = e === "column" ? t.columnCount : t.rowCount, u = 1; i < l && P(e, t, i, n).offset < s;)i += u, u *= 2; return ge(e, t, n, Math.min(i, l - 1), Math.floor(i / 2), s) }, ce = function (e, t, n, i, s, l, u) { var c = e === "column" ? t.width : t.height, v = P(e, t, n, l), m = e === "column" ? ve(t, l) : pe(t, l), w = Math.max(0, Math.min(m - c, v.offset)), g = Math.max(0, v.offset - c + u + v.size); switch (i === "smart" && (s >= g - c && s <= w + c ? i = "auto" : i = "center"), i) { case "start": return w; case "end": return g; case "center": return Math.round(g + (w - g) / 2); case "auto": default: return s >= g && s <= w ? s : g > w || s < g ? g : w } }, Qe = me({ getColumnOffset: function (e, t, n) { return P("column", e, t, n).offset }, getColumnStartIndexForOffset: function (e, t, n) { return ue("column", e, n, t) }, getColumnStopIndexForStartIndex: function (e, t, n, i) { for (var s = e.columnCount, l = e.width, u = P("column", e, t, i), c = n + l, v = u.offset + u.size, m = t; m < s - 1 && v < c;)m++, v += P("column", e, m, i).size; return m }, getColumnWidth: function (e, t, n) { return n.columnMetadataMap[t].size }, getEstimatedTotalHeight: pe, getEstimatedTotalWidth: ve, getOffsetForColumnAndAlignment: function (e, t, n, i, s, l) { return ce("column", e, t, n, i, s, l) }, getOffsetForRowAndAlignment: function (e, t, n, i, s, l) { return ce("row", e, t, n, i, s, l) }, getRowOffset: function (e, t, n) { return P("row", e, t, n).offset }, getRowHeight: function (e, t, n) { return n.rowMetadataMap[t].size }, getRowStartIndexForOffset: function (e, t, n) { return ue("row", e, n, t) }, getRowStopIndexForStartIndex: function (e, t, n, i) { for (var s = e.rowCount, l = e.height, u = P("row", e, t, i), c = n + l, v = u.offset + u.size, m = t; m < s - 1 && v < c;)m++, v += P("row", e, m, i).size; return m }, initInstanceProps: function (e, t) { var n = e, i = n.estimatedColumnWidth, s = n.estimatedRowHeight, l = { columnMetadataMap: {}, estimatedColumnWidth: i || se, estimatedRowHeight: s || se, lastMeasuredColumnIndex: -1, lastMeasuredRowIndex: -1, rowMetadataMap: {} }; return t.resetAfterColumnIndex = function (u, c) { c === void 0 && (c = !0), t.resetAfterIndices({ columnIndex: u, shouldForceUpdate: c }) }, t.resetAfterRowIndex = function (u, c) { c === void 0 && (c = !0), t.resetAfterIndices({ rowIndex: u, shouldForceUpdate: c }) }, t.resetAfterIndices = function (u) { var c = u.columnIndex, v = u.rowIndex, m = u.shouldForceUpdate, w = m === void 0 ? !0 : m; typeof c == "number" && (l.lastMeasuredColumnIndex = Math.min(l.lastMeasuredColumnIndex, c - 1)), typeof v == "number" && (l.lastMeasuredRowIndex = Math.min(l.lastMeasuredRowIndex, v - 1)), t._getItemStyleCache(-1), w && t.forceUpdate() }, l }, shouldResetStyleCacheOnItemSizeChange: !1, validateProps: function (e) { var t = e.columnWidth, n = e.rowHeight } }), We = 150, Ee = function (e, t) { return e }; function Se(o) { var e, t = o.getItemOffset, n = o.getEstimatedTotalSize, i = o.getItemSize, s = o.getOffsetForIndexAndAlignment, l = o.getStartIndexForOffset, u = o.getStopIndexForStartIndex, c = o.initInstanceProps, v = o.shouldResetStyleCacheOnItemSizeChange, m = o.validateProps; return e = (function (w) { ee(g, w); function g(z) { var a; return a = w.call(this, z) || this, a._instanceProps = c(a.props, J(a)), a._outerRef = void 0, a._resetIsScrollingTimeoutId = null, a.state = { instance: J(a), isScrolling: !1, scrollDirection: "forward", scrollOffset: typeof a.props.initialScrollOffset == "number" ? a.props.initialScrollOffset : 0, scrollUpdateWasRequested: !1 }, a._callOnItemsRendered = void 0, a._callOnItemsRendered = j(function (h, p, C, M) { return a.props.onItemsRendered({ overscanStartIndex: h, overscanStopIndex: p, visibleStartIndex: C, visibleStopIndex: M }) }), a._callOnScroll = void 0, a._callOnScroll = j(function (h, p, C) { return a.props.onScroll({ scrollDirection: h, scrollOffset: p, scrollUpdateWasRequested: C }) }), a._getItemStyle = void 0, a._getItemStyle = function (h) { var p = a.props, C = p.direction, M = p.itemSize, y = p.layout, r = a._getItemStyleCache(v && M, v && y, v && C), f; if (r.hasOwnProperty(h)) f = r[h]; else { var d = t(a.props, h, a._instanceProps), S = i(a.props, h, a._instanceProps), x = C === "horizontal" || y === "horizontal", I = C === "rtl", R = x ? d : 0; r[h] = f = { position: "absolute", left: I ? void 0 : R, right: I ? R : void 0, top: x ? 0 : d, height: x ? "100%" : S, width: x ? S : "100%" } } return f }, a._getItemStyleCache = void 0, a._getItemStyleCache = j(function (h, p, C) { return {} }), a._onScrollHorizontal = function (h) { var p = h.currentTarget, C = p.clientWidth, M = p.scrollLeft, y = p.scrollWidth; a.setState(function (r) { if (r.scrollOffset === M) return null; var f = a.props.direction, d = M; if (f === "rtl") switch (Y()) { case "negative": d = -M; break; case "positive-descending": d = y - C - M; break }return d = Math.max(0, Math.min(d, y - C)), { isScrolling: !0, scrollDirection: r.scrollOffset < d ? "forward" : "backward", scrollOffset: d, scrollUpdateWasRequested: !1 } }, a._resetIsScrollingDebounced) }, a._onScrollVertical = function (h) { var p = h.currentTarget, C = p.clientHeight, M = p.scrollHeight, y = p.scrollTop; a.setState(function (r) { if (r.scrollOffset === y) return null; var f = Math.max(0, Math.min(y, M - C)); return { isScrolling: !0, scrollDirection: r.scrollOffset < f ? "forward" : "backward", scrollOffset: f, scrollUpdateWasRequested: !1 } }, a._resetIsScrollingDebounced) }, a._outerRefSetter = function (h) { var p = a.props.outerRef; a._outerRef = h, typeof p == "function" ? p(h) : p != null && typeof p == "object" && p.hasOwnProperty("current") && (p.current = h) }, a._resetIsScrollingDebounced = function () { a._resetIsScrollingTimeoutId !== null && X(a._resetIsScrollingTimeoutId), a._resetIsScrollingTimeoutId = he(a._resetIsScrolling, We) }, a._resetIsScrolling = function () { a._resetIsScrollingTimeoutId = null, a.setState({ isScrolling: !1 }, function () { a._getItemStyleCache(-1, null) }) }, a } g.getDerivedStateFromProps = function (a, h) { return _e(a, h), m(a), null }; var T = g.prototype; return T.scrollTo = function (a) { a = Math.max(0, a), this.setState(function (h) { return h.scrollOffset === a ? null : { scrollDirection: h.scrollOffset < a ? "forward" : "backward", scrollOffset: a, scrollUpdateWasRequested: !0 } }, this._resetIsScrollingDebounced) }, T.scrollToItem = function (a, h) { h === void 0 && (h = "auto"); var p = this.props, C = p.itemCount, M = p.layout, y = this.state.scrollOffset; a = Math.max(0, Math.min(a, C - 1)); var r = 0; if (this._outerRef) { var f = this._outerRef; M === "vertical" ? r = f.scrollWidth > f.clientWidth ? re() : 0 : r = f.scrollHeight > f.clientHeight ? re() : 0 } this.scrollTo(s(this.props, a, h, y, this._instanceProps, r)) }, T.componentDidMount = function () { var a = this.props, h = a.direction, p = a.initialScrollOffset, C = a.layout; if (typeof p == "number" && this._outerRef != null) { var M = this._outerRef; h === "horizontal" || C === "horizontal" ? M.scrollLeft = p : M.scrollTop = p } this._callPropsCallbacks() }, T.componentDidUpdate = function () { var a = this.props, h = a.direction, p = a.layout, C = this.state, M = C.scrollOffset, y = C.scrollUpdateWasRequested; if (y && this._outerRef != null) { var r = this._outerRef; if (h === "horizontal" || p === "horizontal") if (h === "rtl") switch (Y()) { case "negative": r.scrollLeft = -M; break; case "positive-ascending": r.scrollLeft = M; break; default: var f = r.clientWidth, d = r.scrollWidth; r.scrollLeft = d - f - M; break } else r.scrollLeft = M; else r.scrollTop = M } this._callPropsCallbacks() }, T.componentWillUnmount = function () { this._resetIsScrollingTimeoutId !== null && X(this._resetIsScrollingTimeoutId) }, T.render = function () { var a = this.props, h = a.children, p = a.className, C = a.direction, M = a.height, y = a.innerRef, r = a.innerElementType, f = a.innerTagName, d = a.itemCount, S = a.itemData, x = a.itemKey, I = x === void 0 ? Ee : x, R = a.layout, b = a.outerElementType, _ = a.outerTagName, W = a.style, E = a.useIsScrolling, O = a.width, N = this.state.isScrolling, A = C === "horizontal" || R === "horizontal", H = A ? this._onScrollHorizontal : this._onScrollVertical, F = this._getRangeToRender(), L = F[0], k = F[1], U = []; if (d > 0) for (var D = L; D <= k; D++)U.push(K(h, { data: S, key: I(D, S), index: D, isScrolling: E ? N : void 0, style: this._getItemStyle(D) })); var V = n(this.props, this._instanceProps); return K(b || _ || "div", { className: p, onScroll: H, ref: this._outerRefSetter, style: Z({ position: "relative", height: M, width: O, overflow: "auto", WebkitOverflowScrolling: "touch", willChange: "transform", direction: C }, W) }, K(r || f || "div", { children: U, ref: y, style: { height: A ? "100%" : V, pointerEvents: N ? "none" : void 0, width: A ? V : "100%" } })) }, T._callPropsCallbacks = function () { if (typeof this.props.onItemsRendered == "function") { var a = this.props.itemCount; if (a > 0) { var h = this._getRangeToRender(), p = h[0], C = h[1], M = h[2], y = h[3]; this._callOnItemsRendered(p, C, M, y) } } if (typeof this.props.onScroll == "function") { var r = this.state, f = r.scrollDirection, d = r.scrollOffset, S = r.scrollUpdateWasRequested; this._callOnScroll(f, d, S) } }, T._getRangeToRender = function () { var a = this.props, h = a.itemCount, p = a.overscanCount, C = this.state, M = C.isScrolling, y = C.scrollDirection, r = C.scrollOffset; if (h === 0) return [0, 0, 0, 0]; var f = l(this.props, r, this._instanceProps), d = u(this.props, f, r, this._instanceProps), S = !M || y === "backward" ? Math.max(1, p) : 1, x = !M || y === "forward" ? Math.max(1, p) : 1; return [Math.max(0, f - S), Math.max(0, Math.min(h - 1, d + x)), f, d] }, g })(fe), e.defaultProps = { direction: "ltr", itemData: void 0, layout: "vertical", overscanCount: 2, useIsScrolling: !1 }, e } var _e = function (e, t) { var n = e.children, i = e.direction, s = e.height, l = e.layout, u = e.innerTagName, c = e.outerTagName, v = e.width, m = t.instance; if (0) var w }, Ne = 50, q = function (e, t, n) { var i = e, s = i.itemSize, l = n.itemMetadataMap, u = n.lastMeasuredIndex; if (t > u) { var c = 0; if (u >= 0) { var v = l[u]; c = v.offset + v.size } for (var m = u + 1; m <= t; m++) { var w = s(m); l[m] = { offset: c, size: w }, c += w } n.lastMeasuredIndex = t } return l[t] }, Ae = function (e, t, n) { var i = t.itemMetadataMap, s = t.lastMeasuredIndex, l = s > 0 ? i[s].offset : 0; return l >= n ? we(e, t, s, 0, n) : Fe(e, t, Math.max(0, s), n) }, we = function (e, t, n, i, s) { for (; i <= n;) { var l = i + Math.floor((n - i) / 2), u = q(e, l, t).offset; if (u === s) return l; u < s ? i = l + 1 : u > s && (n = l - 1) } return i > 0 ? i - 1 : 0 }, Fe = function (e, t, n, i) { for (var s = e.itemCount, l = 1; n < s && q(e, n, t).offset < i;)n += l, l *= 2; return we(e, t, Math.min(n, s - 1), Math.floor(n / 2), i) }, de = function (e, t) { var n = e.itemCount, i = t.itemMetadataMap, s = t.estimatedItemSize, l = t.lastMeasuredIndex, u = 0; if (l >= n && (l = n - 1), l >= 0) { var c = i[l]; u = c.offset + c.size } var v = n - l - 1, m = v * s; return u + m }, Xe = Se({ getItemOffset: function (e, t, n) { return q(e, t, n).offset }, getItemSize: function (e, t, n) { return n.itemMetadataMap[t].size }, getEstimatedTotalSize: de, getOffsetForIndexAndAlignment: function (e, t, n, i, s, l) { var u = e.direction, c = e.height, v = e.layout, m = e.width, w = u === "horizontal" || v === "horizontal", g = w ? m : c, T = q(e, t, s), z = de(e, s), a = Math.max(0, Math.min(z - g, T.offset)), h = Math.max(0, T.offset - g + T.size + l); switch (n === "smart" && (i >= h - g && i <= a + g ? n = "auto" : n = "center"), n) { case "start": return a; case "end": return h; case "center": return Math.round(h + (a - h) / 2); case "auto": default: return i >= h && i <= a ? i : i < h ? h : a } }, getStartIndexForOffset: function (e, t, n) { return Ae(e, n, t) }, getStopIndexForStartIndex: function (e, t, n, i) { for (var s = e.direction, l = e.height, u = e.itemCount, c = e.layout, v = e.width, m = s === "horizontal" || c === "horizontal", w = m ? v : l, g = q(e, t, i), T = n + w, z = g.offset + g.size, a = t; a < u - 1 && z < T;)a++, z += q(e, a, i).size; return a }, initInstanceProps: function (e, t) { var n = e, i = n.estimatedItemSize, s = { itemMetadataMap: {}, estimatedItemSize: i || Ne, lastMeasuredIndex: -1 }; return t.resetAfterIndex = function (l, u) { u === void 0 && (u = !0), s.lastMeasuredIndex = Math.min(s.lastMeasuredIndex, l - 1), t._getItemStyleCache(-1), u && t.forceUpdate() }, s }, shouldResetStyleCacheOnItemSizeChange: !1, validateProps: function (e) { var t = e.itemSize } }), Ye = me({ getColumnOffset: function (e, t) { var n = e.columnWidth; return t * n }, getColumnWidth: function (e, t) { var n = e.columnWidth; return n }, getRowOffset: function (e, t) { var n = e.rowHeight; return t * n }, getRowHeight: function (e, t) { var n = e.rowHeight; return n }, getEstimatedTotalHeight: function (e) { var t = e.rowCount, n = e.rowHeight; return n * t }, getEstimatedTotalWidth: function (e) { var t = e.columnCount, n = e.columnWidth; return n * t }, getOffsetForColumnAndAlignment: function (e, t, n, i, s, l) { var u = e.columnCount, c = e.columnWidth, v = e.width, m = Math.max(0, u * c - v), w = Math.min(m, t * c), g = Math.max(0, t * c - v + l + c); switch (n === "smart" && (i >= g - v && i <= w + v ? n = "auto" : n = "center"), n) { case "start": return w; case "end": return g; case "center": var T = Math.round(g + (w - g) / 2); return T < Math.ceil(v / 2) ? 0 : T > m + Math.floor(v / 2) ? m : T; case "auto": default: return i >= g && i <= w ? i : g > w || i < g ? g : w } }, getOffsetForRowAndAlignment: function (e, t, n, i, s, l) { var u = e.rowHeight, c = e.height, v = e.rowCount, m = Math.max(0, v * u - c), w = Math.min(m, t * u), g = Math.max(0, t * u - c + l + u); switch (n === "smart" && (i >= g - c && i <= w + c ? n = "auto" : n = "center"), n) { case "start": return w; case "end": return g; case "center": var T = Math.round(g + (w - g) / 2); return T < Math.ceil(c / 2) ? 0 : T > m + Math.floor(c / 2) ? m : T; case "auto": default: return i >= g && i <= w ? i : g > w || i < g ? g : w } }, getColumnStartIndexForOffset: function (e, t) { var n = e.columnWidth, i = e.columnCount; return Math.max(0, Math.min(i - 1, Math.floor(t / n))) }, getColumnStopIndexForStartIndex: function (e, t, n) { var i = e.columnWidth, s = e.columnCount, l = e.width, u = t * i, c = Math.ceil((l + n - u) / i); return Math.max(0, Math.min(s - 1, t + c - 1)) }, getRowStartIndexForOffset: function (e, t) { var n = e.rowHeight, i = e.rowCount; return Math.max(0, Math.min(i - 1, Math.floor(t / n))) }, getRowStopIndexForStartIndex: function (e, t, n) { var i = e.rowHeight, s = e.rowCount, l = e.height, u = t * i, c = Math.ceil((l + n - u) / i); return Math.max(0, Math.min(s - 1, t + c - 1)) }, initInstanceProps: function (e) { }, shouldResetStyleCacheOnItemSizeChange: !0, validateProps: function (e) { var t = e.columnWidth, n = e.rowHeight } }), et = Se({ getItemOffset: function (e, t) { var n = e.itemSize; return t * n }, getItemSize: function (e, t) { var n = e.itemSize; return n }, getEstimatedTotalSize: function (e) { var t = e.itemCount, n = e.itemSize; return n * t }, getOffsetForIndexAndAlignment: function (e, t, n, i, s, l) { var u = e.direction, c = e.height, v = e.itemCount, m = e.itemSize, w = e.layout, g = e.width, T = u === "horizontal" || w === "horizontal", z = T ? g : c, a = Math.max(0, v * m - z), h = Math.min(a, t * m), p = Math.max(0, t * m - z + m + l); switch (n === "smart" && (i >= p - z && i <= h + z ? n = "auto" : n = "center"), n) { case "start": return h; case "end": return p; case "center": { var C = Math.round(p + (h - p) / 2); return C < Math.ceil(z / 2) ? 0 : C > a + Math.floor(z / 2) ? a : C } case "auto": default: return i >= p && i <= h ? i : i < p ? p : h } }, getStartIndexForOffset: function (e, t) { var n = e.itemCount, i = e.itemSize; return Math.max(0, Math.min(n - 1, Math.floor(t / i))) }, getStopIndexForStartIndex: function (e, t, n) { var i = e.direction, s = e.height, l = e.itemCount, u = e.itemSize, c = e.layout, v = e.width, m = i === "horizontal" || c === "horizontal", w = t * u, g = m ? v : s, T = Math.ceil((g + n - w) / u); return Math.max(0, Math.min(l - 1, t + T - 1)) }, initInstanceProps: function (e) { }, shouldResetStyleCacheOnItemSizeChange: !0, validateProps: function (e) { var t = e.itemSize } }); function oe(o, e) { for (var t in o) if (!(t in e)) return !0; for (var n in e) if (o[n] !== e[n]) return !0; return !1 } var He = ["style"], De = ["style"]; function Pe(o, e) { var t = o.style, n = te(o, He), i = e.style, s = te(e, De); return !oe(t, i) && !oe(n, s) } function tt(o, e) { return !Pe(this.props, o) || oe(this.state, e) } export { Ye as FixedSizeGrid, et as FixedSizeList, Qe as VariableSizeGrid, Xe as VariableSizeList, Pe as areEqual, tt as shouldComponentUpdate };
//# sourceMappingURL=react-window.mjs.map