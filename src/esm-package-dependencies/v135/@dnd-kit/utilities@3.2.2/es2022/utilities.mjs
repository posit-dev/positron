/* esm.sh - esbuild bundle(@dnd-kit/utilities@3.2.2) es2022 production */
import { useMemo as l, useLayoutEffect as R, useEffect as g, useRef as o, useCallback as i } from "react"; function Y() { for (var n = arguments.length, t = new Array(n), e = 0; e < n; e++) { t[e] = arguments[e]; } return l(() => u => { t.forEach(r => r(u)) }, t) } const D = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; function a(n) { const t = Object.prototype.toString.call(n); return t === "[object Window]" || t === "[object global]" } function b(n) { return "nodeType" in n } function c(n) { let t, e; return n ? a(n) ? n : b(n) && (t = (e = n.ownerDocument) == null ? void 0 : e.defaultView) != null ? t : window : window } function j(n) { const { Document: t } = c(n); return n instanceof t } function C(n) { return a(n) ? !1 : n instanceof c(n).HTMLElement } function L(n) { return n instanceof c(n).SVGElement } function x(n) { return n ? a(n) ? n.document : b(n) ? j(n) ? n : C(n) || L(n) ? n.ownerDocument : document : document : document } const E = D ? R : g; function M(n) { const t = o(n); return E(() => { t.current = n }), i(function () { for (var e = arguments.length, u = new Array(e), r = 0; r < e; r++) { u[r] = arguments[r]; } return t.current == null ? void 0 : t.current(...u) }, []) } function A() { const n = o(null), t = i((u, r) => { n.current = setInterval(u, r) }, []), e = i(() => { n.current !== null && (clearInterval(n.current), n.current = null) }, []); return [t, e] } function I(n, t) { t === void 0 && (t = [n]); const e = o(n); return E(() => { e.current !== n && (e.current = n) }, t), e } function v(n, t) { const e = o(); return l(() => { const u = n(e.current); return e.current = u, u }, [...t]) } function N(n) { const t = M(n), e = o(null), u = i(r => { r !== e.current && t?.(r, e.current), e.current = r }, []); return [e, u] } function F(n) { const t = o(); return g(() => { t.current = n }, [n]), t.current } const f = {}; function H(n, t) { return l(() => { if (t) { return t; } const e = f[n] == null ? 0 : f[n] + 1; return f[n] = e, n + "-" + e }, [n, t]) } function S(n) { return function (t) { for (var e = arguments.length, u = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) { u[r - 1] = arguments[r]; } return u.reduce((s, T) => { const y = Object.entries(T); for (const [d, p] of y) { const m = s[d]; m != null && (s[d] = m + n * p) } return s }, { ...t }) } } const W = S(1), q = S(-1); function O(n) { return "clientX" in n && "clientY" in n } function z(n) { if (!n) { return !1; } const { KeyboardEvent: t } = c(n.target); return t && n instanceof t } function V(n) { if (!n) { return !1; } const { TouchEvent: t } = c(n.target); return t && n instanceof t } function G(n) { if (V(n)) { if (n.touches && n.touches.length) { const { clientX: t, clientY: e } = n.touches[0]; return { x: t, y: e } } else if (n.changedTouches && n.changedTouches.length) { const { clientX: t, clientY: e } = n.changedTouches[0]; return { x: t, y: e } } } return O(n) ? { x: n.clientX, y: n.clientY } : null } var w = Object.freeze({ Translate: { toString(n) { if (!n) { return; } const { x: t, y: e } = n; return "translate3d(" + (t ? Math.round(t) : 0) + "px, " + (e ? Math.round(e) : 0) + "px, 0)" } }, Scale: { toString(n) { if (!n) { return; } const { scaleX: t, scaleY: e } = n; return "scaleX(" + t + ") scaleY(" + e + ")" } }, Transform: { toString(n) { if (n) { return [w.Translate.toString(n), w.Scale.toString(n)].join(" ") } } }, Transition: { toString(n) { const { property: t, duration: e, easing: u } = n; return t + " " + e + "ms " + u } } }), h = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]"; function K(n) { return n.matches(h) ? n : n.querySelector(h) } export { w as CSS, W as add, D as canUseDOM, K as findFirstFocusableNode, G as getEventCoordinates, x as getOwnerDocument, c as getWindow, O as hasViewportRelativeCoordinates, j as isDocument, C as isHTMLElement, z as isKeyboardEvent, b as isNode, L as isSVGElement, V as isTouchEvent, a as isWindow, q as subtract, Y as useCombinedRefs, M as useEvent, A as useInterval, E as useIsomorphicLayoutEffect, I as useLatestValue, v as useLazyMemo, N as useNodeRef, F as usePrevious, H as useUniqueId };
//# sourceMappingURL=utilities.mjs.map