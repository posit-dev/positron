{"mappings":"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","names":["arrayMove","array","from","to","newArray","slice","splice","length","arraySwap","getSortedRects","items","rects","reduce","accumulator","id","index","rect","get","Array","isValidIndex","itemsEqual","a","b","i","normalizeDisabled","disabled","draggable","droppable","defaultScale","scaleX","scaleY","horizontalListSortingStrategy","_ref","activeNodeRect","fallbackActiveRect","activeIndex","overIndex","_rects$activeIndex","itemGap","getItemGap","newIndexRect","x","left","width","y","currentRect","previousRect","nextRect","rectSortingStrategy","newRects","oldRect","newRect","top","height","rectSwappingStrategy","verticalListSortingStrategy","overIndexRect","clientRects","ID_PREFIX","Context","React","createContext","containerId","disableTransforms","useDragOverlay","sortedRects","strategy","SortableContext","children","userDefinedItems","disabledProp","active","dragOverlay","droppableRects","over","measureDroppableContainers","useDndContext","useUniqueId","useMemo","map","item","isDragging","indexOf","previousItemsRef","useRef","itemsHaveChanged","current","useIsomorphicLayoutEffect","useEffect","contextValue","Provider","value","defaultNewIndexGetter","defaultAnimateLayoutChanges","_ref2","isSorting","wasDragging","newIndex","previousItems","previousContainerId","transition","defaultTransition","duration","easing","transitionProperty","disabledTransition","CSS","Transition","toString","property","defaultAttributes","roleDescription","useDerivedTransform","node","derivedTransform","setDerivedtransform","useState","previousIndex","initial","getClientRect","ignoreTransform","delta","useSortable","animateLayoutChanges","attributes","userDefinedAttributes","localDisabled","data","customData","getNewIndex","localStrategy","resizeObserverConfig","globalDisabled","globalStrategy","useContext","normalizeLocalDisabled","sortable","itemsAfterCurrentSortable","isOver","setNodeRef","setDroppableNodeRef","useDroppable","updateMeasurementsFor","activatorEvent","setDraggableNodeRef","listeners","setActivatorNodeRef","transform","useDraggable","useCombinedRefs","Boolean","displaceItem","shouldDisplaceDragSource","dragSourceDisplacement","finalTransform","activeId","previous","shouldAnimateLayoutChanges","timeoutId","setTimeout","clearTimeout","getTransition","isKeyboardEvent","_localDisabled$dragga","_localDisabled$droppa","hasSortableData","entry","directions","KeyboardCode","Down","Right","Up","Left","sortableKeyboardCoordinates","event","context","collisionRect","droppableContainers","scrollableAncestors","includes","code","preventDefault","filteredContainers","getEnabled","forEach","push","collisions","closestCorners","pointerCoordinates","closestId","getFirstCollision","activeDroppable","newDroppable","newNode","hasDifferentScrollAncestors","getScrollableAncestors","some","element","hasSameContainer","isSameContainer","isAfterActive","isAfter","offset","rectCoordinates","subtract"],"sourceRoot":"/","sources":["../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/utilities/arrayMove.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/utilities/arraySwap.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/utilities/getSortedRects.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/utilities/isValidIndex.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/utilities/itemsEqual.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/utilities/normalizeDisabled.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/strategies/horizontalListSorting.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/strategies/rectSorting.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/strategies/rectSwapping.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/strategies/verticalListSorting.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/components/SortableContext.tsx","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/hooks/defaults.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/hooks/utilities/useDerivedTransform.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/hooks/useSortable.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/types/type-guard.ts","../esmd/npm/@dnd-kit/sortable@10.0.0/node_modules/.pnpm/@dnd-kit+sortable@10.0.0_@dnd-kit+core@6.3.0_react@18.3.1/node_modules/@dnd-kit/sortable/src/sensors/keyboard/sortableKeyboardCoordinates.ts"],"sourcesContent":["/**\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\n */\nexport function arrayMove\u003cT\u003e(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n  newArray.splice(\n    to \u003c 0 ? newArray.length + to : to,\n    0,\n    newArray.splice(from, 1)[0]\n  );\n\n  return newArray;\n}\n","/**\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\n */\nexport function arraySwap\u003cT\u003e(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n\n  newArray[from] = array[to];\n  newArray[to] = array[from];\n\n  return newArray;\n}\n","import type {\n  ClientRect,\n  UniqueIdentifier,\n  UseDndContextReturnValue,\n} from '@dnd-kit/core';\n\nexport function getSortedRects(\n  items: UniqueIdentifier[],\n  rects: UseDndContextReturnValue['droppableRects']\n) {\n  return items.reduce\u003cClientRect[]\u003e((accumulator, id, index) =\u003e {\n    const rect = rects.get(id);\n\n    if (rect) {\n      accumulator[index] = rect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n","export function isValidIndex(index: number | null): index is number {\n  return index !== null \u0026\u0026 index \u003e= 0;\n}\n","import type {UniqueIdentifier} from '@dnd-kit/core';\n\nexport function itemsEqual(a: UniqueIdentifier[], b: UniqueIdentifier[]) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i \u003c a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type {Disabled} from '../types';\n\nexport function normalizeDisabled(disabled: boolean | Disabled): Disabled {\n  if (typeof disabled === 'boolean') {\n    return {\n      draggable: disabled,\n      droppable: disabled,\n    };\n  }\n\n  return disabled;\n}\n","import type {ClientRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const horizontalListSortingStrategy: SortingStrategy = ({\n  rects,\n  activeNodeRect: fallbackActiveRect,\n  activeIndex,\n  overIndex,\n  index,\n}) =\u003e {\n  const activeNodeRect = rects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(rects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = rects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x:\n        activeIndex \u003c overIndex\n          ? newIndexRect.left +\n            newIndexRect.width -\n            (activeNodeRect.left + activeNodeRect.width)\n          : newIndexRect.left - activeNodeRect.left,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index \u003e activeIndex \u0026\u0026 index \u003c= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index \u003c activeIndex \u0026\u0026 index \u003e= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(rects: ClientRect[], index: number, activeIndex: number) {\n  const currentRect: ClientRect | undefined = rects[index];\n  const previousRect: ClientRect | undefined = rects[index - 1];\n  const nextRect: ClientRect | undefined = rects[index + 1];\n\n  if (!currentRect || (!previousRect \u0026\u0026 !nextRect)) {\n    return 0;\n  }\n\n  if (activeIndex \u003c index) {\n    return previousRect\n      ? currentRect.left - (previousRect.left + previousRect.width)\n      : nextRect.left - (currentRect.left + currentRect.width);\n  }\n\n  return nextRect\n    ? nextRect.left - (currentRect.left + currentRect.width)\n    : currentRect.left - (previousRect.left + previousRect.width);\n}\n","import {arrayMove} from '../utilities';\nimport type {SortingStrategy} from '../types';\n\nexport const rectSortingStrategy: SortingStrategy = ({\n  rects,\n  activeIndex,\n  overIndex,\n  index,\n}) =\u003e {\n  const newRects = arrayMove(rects, overIndex, activeIndex);\n\n  const oldRect = rects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {SortingStrategy} from '../types';\n\nexport const rectSwappingStrategy: SortingStrategy = ({\n  activeIndex,\n  index,\n  rects,\n  overIndex,\n}) =\u003e {\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = rects[index];\n    newRect = rects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = rects[index];\n    newRect = rects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {ClientRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const verticalListSortingStrategy: SortingStrategy = ({\n  activeIndex,\n  activeNodeRect: fallbackActiveRect,\n  index,\n  rects,\n  overIndex,\n}) =\u003e {\n  const activeNodeRect = rects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = rects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y:\n        activeIndex \u003c overIndex\n          ? overIndexRect.top +\n            overIndexRect.height -\n            (activeNodeRect.top + activeNodeRect.height)\n          : overIndexRect.top - activeNodeRect.top,\n      ...defaultScale,\n    };\n  }\n\n  const itemGap = getItemGap(rects, index, activeIndex);\n\n  if (index \u003e activeIndex \u0026\u0026 index \u003c= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale,\n    };\n  }\n\n  if (index \u003c activeIndex \u0026\u0026 index \u003e= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  clientRects: ClientRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect: ClientRect | undefined = clientRects[index];\n  const previousRect: ClientRect | undefined = clientRects[index - 1];\n  const nextRect: ClientRect | undefined = clientRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex \u003c index) {\n    return previousRect\n      ? currentRect.top - (previousRect.top + previousRect.height)\n      : nextRect\n      ? nextRect.top - (currentRect.top + currentRect.height)\n      : 0;\n  }\n\n  return nextRect\n    ? nextRect.top - (currentRect.top + currentRect.height)\n    : previousRect\n    ? currentRect.top - (previousRect.top + previousRect.height)\n    : 0;\n}\n","import React, {useEffect, useMemo, useRef} from 'react';\nimport {useDndContext, ClientRect, UniqueIdentifier} from '@dnd-kit/core';\nimport {useIsomorphicLayoutEffect, useUniqueId} from '@dnd-kit/utilities';\n\nimport type {Disabled, SortingStrategy} from '../types';\nimport {getSortedRects, itemsEqual, normalizeDisabled} from '../utilities';\nimport {rectSortingStrategy} from '../strategies';\n\nexport interface Props {\n  children: React.ReactNode;\n  items: (UniqueIdentifier | {id: UniqueIdentifier})[];\n  strategy?: SortingStrategy;\n  id?: string;\n  disabled?: boolean | Disabled;\n}\n\nconst ID_PREFIX = 'Sortable';\n\ninterface ContextDescriptor {\n  activeIndex: number;\n  containerId: string;\n  disabled: Disabled;\n  disableTransforms: boolean;\n  items: UniqueIdentifier[];\n  overIndex: number;\n  useDragOverlay: boolean;\n  sortedRects: ClientRect[];\n  strategy: SortingStrategy;\n}\n\nexport const Context = React.createContext\u003cContextDescriptor\u003e({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  disabled: {\n    draggable: false,\n    droppable: false,\n  },\n});\n\nexport function SortableContext({\n  children,\n  id,\n  items: userDefinedItems,\n  strategy = rectSortingStrategy,\n  disabled: disabledProp = false,\n}: Props) {\n  const {\n    active,\n    dragOverlay,\n    droppableRects,\n    over,\n    measureDroppableContainers,\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(dragOverlay.rect !== null);\n  const items = useMemo\u003cUniqueIdentifier[]\u003e(\n    () =\u003e\n      userDefinedItems.map((item) =\u003e\n        typeof item === 'object' \u0026\u0026 'id' in item ? item.id : item\n      ),\n    [userDefinedItems]\n  );\n  const isDragging = active != null;\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);\n  const disableTransforms =\n    (overIndex !== -1 \u0026\u0026 activeIndex === -1) || itemsHaveChanged;\n  const disabled = normalizeDisabled(disabledProp);\n\n  useIsomorphicLayoutEffect(() =\u003e {\n    if (itemsHaveChanged \u0026\u0026 isDragging) {\n      measureDroppableContainers(items);\n    }\n  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);\n\n  useEffect(() =\u003e {\n    previousItemsRef.current = items;\n  }, [items]);\n\n  const contextValue = useMemo(\n    (): ContextDescriptor =\u003e ({\n      activeIndex,\n      containerId,\n      disabled,\n      disableTransforms,\n      items,\n      overIndex,\n      useDragOverlay,\n      sortedRects: getSortedRects(items, droppableRects),\n      strategy,\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      activeIndex,\n      containerId,\n      disabled.draggable,\n      disabled.droppable,\n      disableTransforms,\n      items,\n      overIndex,\n      droppableRects,\n      useDragOverlay,\n      strategy,\n    ]\n  );\n\n  return \u003cContext.Provider value={contextValue}\u003e{children}\u003c/Context.Provider\u003e;\n}\n","import {CSS} from '@dnd-kit/utilities';\n\nimport {arrayMove} from '../utilities';\n\nimport type {\n  AnimateLayoutChanges,\n  NewIndexGetter,\n  SortableTransition,\n} from './types';\n\nexport const defaultNewIndexGetter: NewIndexGetter = ({\n  id,\n  items,\n  activeIndex,\n  overIndex,\n}) =\u003e arrayMove(items, activeIndex, overIndex).indexOf(id);\n\nexport const defaultAnimateLayoutChanges: AnimateLayoutChanges = ({\n  containerId,\n  isSorting,\n  wasDragging,\n  index,\n  items,\n  newIndex,\n  previousItems,\n  previousContainerId,\n  transition,\n}) =\u003e {\n  if (!transition || !wasDragging) {\n    return false;\n  }\n\n  if (previousItems !== items \u0026\u0026 index === newIndex) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index \u0026\u0026 containerId === previousContainerId;\n};\n\nexport const defaultTransition: SortableTransition = {\n  duration: 200,\n  easing: 'ease',\n};\n\nexport const transitionProperty = 'transform';\n\nexport const disabledTransition = CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear',\n});\n\nexport const defaultAttributes = {\n  roleDescription: 'sortable',\n};\n","import {useEffect, useRef, useState} from 'react';\nimport {getClientRect, ClientRect} from '@dnd-kit/core';\nimport {Transform, useIsomorphicLayoutEffect} from '@dnd-kit/utilities';\n\ninterface Arguments {\n  rect: React.MutableRefObject\u003cClientRect | null\u003e;\n  disabled: boolean;\n  index: number;\n  node: React.MutableRefObject\u003cHTMLElement | null\u003e;\n}\n\n/*\n * When the index of an item changes while sorting,\n * we need to temporarily disable the transforms\n */\nexport function useDerivedTransform({disabled, index, node, rect}: Arguments) {\n  const [derivedTransform, setDerivedtransform] = useState\u003cTransform | null\u003e(\n    null\n  );\n  const previousIndex = useRef(index);\n\n  useIsomorphicLayoutEffect(() =\u003e {\n    if (!disabled \u0026\u0026 index !== previousIndex.current \u0026\u0026 node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getClientRect(node.current, {\n          ignoreTransform: true,\n        });\n\n        const delta = {\n          x: initial.left - current.left,\n          y: initial.top - current.top,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height,\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== previousIndex.current) {\n      previousIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n\n  useEffect(() =\u003e {\n    if (derivedTransform) {\n      setDerivedtransform(null);\n    }\n  }, [derivedTransform]);\n\n  return derivedTransform;\n}\n","import {useContext, useEffect, useMemo, useRef} from 'react';\nimport {\n  useDraggable,\n  useDroppable,\n  UseDraggableArguments,\n  UseDroppableArguments,\n} from '@dnd-kit/core';\nimport type {Data} from '@dnd-kit/core';\nimport {CSS, isKeyboardEvent, useCombinedRefs} from '@dnd-kit/utilities';\n\nimport {Context} from '../components';\nimport type {Disabled, SortableData, SortingStrategy} from '../types';\nimport {isValidIndex} from '../utilities';\nimport {\n  defaultAnimateLayoutChanges,\n  defaultAttributes,\n  defaultNewIndexGetter,\n  defaultTransition,\n  disabledTransition,\n  transitionProperty,\n} from './defaults';\nimport type {\n  AnimateLayoutChanges,\n  NewIndexGetter,\n  SortableTransition,\n} from './types';\nimport {useDerivedTransform} from './utilities';\n\nexport interface Arguments\n  extends Omit\u003cUseDraggableArguments, 'disabled'\u003e,\n    Pick\u003cUseDroppableArguments, 'resizeObserverConfig'\u003e {\n  animateLayoutChanges?: AnimateLayoutChanges;\n  disabled?: boolean | Disabled;\n  getNewIndex?: NewIndexGetter;\n  strategy?: SortingStrategy;\n  transition?: SortableTransition | null;\n}\n\nexport function useSortable({\n  animateLayoutChanges = defaultAnimateLayoutChanges,\n  attributes: userDefinedAttributes,\n  disabled: localDisabled,\n  data: customData,\n  getNewIndex = defaultNewIndexGetter,\n  id,\n  strategy: localStrategy,\n  resizeObserverConfig,\n  transition = defaultTransition,\n}: Arguments) {\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disabled: globalDisabled,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy,\n  } = useContext(Context);\n  const disabled: Disabled = normalizeLocalDisabled(\n    localDisabled,\n    globalDisabled\n  );\n  const index = items.indexOf(id);\n  const data = useMemo\u003cSortableData \u0026 Data\u003e(\n    () =\u003e ({sortable: {containerId, index, items}, ...customData}),\n    [containerId, customData, index, items]\n  );\n  const itemsAfterCurrentSortable = useMemo(\n    () =\u003e items.slice(items.indexOf(id)),\n    [items, id]\n  );\n  const {\n    rect,\n    node,\n    isOver,\n    setNodeRef: setDroppableNodeRef,\n  } = useDroppable({\n    id,\n    data,\n    disabled: disabled.droppable,\n    resizeObserverConfig: {\n      updateMeasurementsFor: itemsAfterCurrentSortable,\n      ...resizeObserverConfig,\n    },\n  });\n  const {\n    active,\n    activatorEvent,\n    activeNodeRect,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    setActivatorNodeRef,\n    transform,\n  } = useDraggable({\n    id,\n    data,\n    attributes: {\n      ...defaultAttributes,\n      ...userDefinedAttributes,\n    },\n    disabled: disabled.draggable,\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem =\n    isSorting \u0026\u0026\n    !disableTransforms \u0026\u0026\n    isValidIndex(activeIndex) \u0026\u0026\n    isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay \u0026\u0026 isDragging;\n  const dragSourceDisplacement =\n    shouldDisplaceDragSource \u0026\u0026 displaceItem ? transform : null;\n  const strategy = localStrategy ?? globalStrategy;\n  const finalTransform = displaceItem\n    ? dragSourceDisplacement ??\n      strategy({\n        rects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index,\n      })\n    : null;\n  const newIndex =\n    isValidIndex(activeIndex) \u0026\u0026 isValidIndex(overIndex)\n      ? getNewIndex({id, items, activeIndex, overIndex})\n      : index;\n  const activeId = active?.id;\n  const previous = useRef({\n    activeId,\n    items,\n    newIndex,\n    containerId,\n  });\n  const itemsHaveChanged = items !== previous.current.items;\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    containerId,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: previous.current.newIndex,\n    previousItems: previous.current.items,\n    previousContainerId: previous.current.containerId,\n    transition,\n    wasDragging: previous.current.activeId != null,\n  });\n\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect,\n  });\n\n  useEffect(() =\u003e {\n    if (isSorting \u0026\u0026 previous.current.newIndex !== newIndex) {\n      previous.current.newIndex = newIndex;\n    }\n\n    if (containerId !== previous.current.containerId) {\n      previous.current.containerId = containerId;\n    }\n\n    if (items !== previous.current.items) {\n      previous.current.items = items;\n    }\n  }, [isSorting, newIndex, containerId, items]);\n\n  useEffect(() =\u003e {\n    if (activeId === previous.current.activeId) {\n      return;\n    }\n\n    if (activeId != null \u0026\u0026 previous.current.activeId == null) {\n      previous.current.activeId = activeId;\n      return;\n    }\n\n    const timeoutId = setTimeout(() =\u003e {\n      previous.current.activeId = activeId;\n    }, 50);\n\n    return () =\u003e clearTimeout(timeoutId);\n  }, [activeId]);\n\n  return {\n    active,\n    activeIndex,\n    attributes,\n    data,\n    rect,\n    index,\n    newIndex,\n    items,\n    isOver,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setActivatorNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform ?? finalTransform,\n    transition: getTransition(),\n  };\n\n  function getTransition() {\n    if (\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      derivedTransform ||\n      // Or to prevent items jumping to back to their \"new\" position when items change\n      (itemsHaveChanged \u0026\u0026 previous.current.newIndex === index)\n    ) {\n      return disabledTransition;\n    }\n\n    if (\n      (shouldDisplaceDragSource \u0026\u0026 !isKeyboardEvent(activatorEvent)) ||\n      !transition\n    ) {\n      return undefined;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({\n        ...transition,\n        property: transitionProperty,\n      });\n    }\n\n    return undefined;\n  }\n}\n\nfunction normalizeLocalDisabled(\n  localDisabled: Arguments['disabled'],\n  globalDisabled: Disabled\n) {\n  if (typeof localDisabled === 'boolean') {\n    return {\n      draggable: localDisabled,\n      // Backwards compatibility\n      droppable: false,\n    };\n  }\n\n  return {\n    draggable: localDisabled?.draggable ?? globalDisabled.draggable,\n    droppable: localDisabled?.droppable ?? globalDisabled.droppable,\n  };\n}\n","import type {\n  Active,\n  Data,\n  DroppableContainer,\n  DraggableNode,\n  Over,\n} from '@dnd-kit/core';\n\nimport type {SortableData} from './data';\n\nexport function hasSortableData\u003c\n  T extends Active | Over | DraggableNode | DroppableContainer\n\u003e(\n  entry: T | null | undefined\n): entry is T \u0026 {data: {current: Data\u003cSortableData\u003e}} {\n  if (!entry) {\n    return false;\n  }\n\n  const data = entry.data.current;\n\n  if (\n    data \u0026\u0026\n    'sortable' in data \u0026\u0026\n    typeof data.sortable === 'object' \u0026\u0026\n    'containerId' in data.sortable \u0026\u0026\n    'items' in data.sortable \u0026\u0026\n    'index' in data.sortable\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import {\n  closestCorners,\n  getScrollableAncestors,\n  getFirstCollision,\n  KeyboardCode,\n  DroppableContainer,\n  KeyboardCoordinateGetter,\n} from '@dnd-kit/core';\nimport {subtract} from '@dnd-kit/utilities';\n\nimport {hasSortableData} from '../../types';\n\nconst directions: string[] = [\n  KeyboardCode.Down,\n  KeyboardCode.Right,\n  KeyboardCode.Up,\n  KeyboardCode.Left,\n];\n\nexport const sortableKeyboardCoordinates: KeyboardCoordinateGetter = (\n  event,\n  {\n    context: {\n      active,\n      collisionRect,\n      droppableRects,\n      droppableContainers,\n      over,\n      scrollableAncestors,\n    },\n  }\n) =\u003e {\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!active || !collisionRect) {\n      return;\n    }\n\n    const filteredContainers: DroppableContainer[] = [];\n\n    droppableContainers.getEnabled().forEach((entry) =\u003e {\n      if (!entry || entry?.disabled) {\n        return;\n      }\n\n      const rect = droppableRects.get(entry.id);\n\n      if (!rect) {\n        return;\n      }\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (collisionRect.top \u003c rect.top) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Up:\n          if (collisionRect.top \u003e rect.top) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Left:\n          if (collisionRect.left \u003e rect.left) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Right:\n          if (collisionRect.left \u003c rect.left) {\n            filteredContainers.push(entry);\n          }\n          break;\n      }\n    });\n\n    const collisions = closestCorners({\n      active,\n      collisionRect: collisionRect,\n      droppableRects,\n      droppableContainers: filteredContainers,\n      pointerCoordinates: null,\n    });\n    let closestId = getFirstCollision(collisions, 'id');\n\n    if (closestId === over?.id \u0026\u0026 collisions.length \u003e 1) {\n      closestId = collisions[1].id;\n    }\n\n    if (closestId != null) {\n      const activeDroppable = droppableContainers.get(active.id);\n      const newDroppable = droppableContainers.get(closestId);\n      const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n      const newNode = newDroppable?.node.current;\n\n      if (newNode \u0026\u0026 newRect \u0026\u0026 activeDroppable \u0026\u0026 newDroppable) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some(\n          (element, index) =\u003e scrollableAncestors[index] !== element\n        );\n        const hasSameContainer = isSameContainer(activeDroppable, newDroppable);\n        const isAfterActive = isAfter(activeDroppable, newDroppable);\n        const offset =\n          hasDifferentScrollAncestors || !hasSameContainer\n            ? {\n                x: 0,\n                y: 0,\n              }\n            : {\n                x: isAfterActive ? collisionRect.width - newRect.width : 0,\n                y: isAfterActive ? collisionRect.height - newRect.height : 0,\n              };\n        const rectCoordinates = {\n          x: newRect.left,\n          y: newRect.top,\n        };\n\n        const newCoordinates =\n          offset.x \u0026\u0026 offset.y\n            ? rectCoordinates\n            : subtract(rectCoordinates, offset);\n\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n\nfunction isSameContainer(a: DroppableContainer, b: DroppableContainer) {\n  if (!hasSortableData(a) || !hasSortableData(b)) {\n    return false;\n  }\n\n  return (\n    a.data.current.sortable.containerId === b.data.current.sortable.containerId\n  );\n}\n\nfunction isAfter(a: DroppableContainer, b: DroppableContainer) {\n  if (!hasSortableData(a) || !hasSortableData(b)) {\n    return false;\n  }\n\n  if (!isSameContainer(a, b)) {\n    return false;\n  }\n\n  return a.data.current.sortable.index \u003c b.data.current.sortable.index;\n}\n"],"version":3}
