name: "Test: E2E (Ubuntu)"

on:
  workflow_call:
    inputs:
      grep:
        required: false
        description: "Only run tests matching this regex. Supports tags (comma-separated), titles, filenames. Confirm pattern matching locally with: npx playwright test --grep=<regex>"
        default: "@:critical"
        type: string
      project:
        required: false
        description: "The name of the Playwright project to run tests for."
        default: "e2e-electron"
        type: string
      workers:
        required: false
        description: "Number of parallel workers to use, defaults to 2."
        default: 2
        type: number
      repeat_each:
        required: false
        description: "Run each test N times, defaults to one."
        default: 1
        type: number
      display_name:
        required: false
        description: "The name of the job as it will appear in the GitHub Actions UI."
        default: "e2e-linux"
        type: string
      currents_tags:
        required: false
        description: "The tags to use for Currents recording."
        default: "@ubuntu"
        type: string
      report_currents:
        required: false
        description: "Whether or not to report results to Currents."
        type: boolean
        default: true
      install_undetectable_interpreters:
        required: false
        description: "Whether or not to install undetectable interpreters."
        type: boolean
        default: false
      install_license:
        required: false
        description: "Whether or not to install positron-license"
        type: boolean
        default: false
      upload_logs:
        required: false
        description: "Whether or not to upload e2e test logs."
        type: boolean
        default: true
      skip_extension_test:
        required: false
        description: "Whether to skip the bootstrap extensions test."
        type: boolean
        default: false
      allow_soft_fail:
        required: false
        description: "Whether to allow tests marked with :soft-fail to fail without failing the job."
        type: boolean
        default: false
      mode:
        required: false
        description: "Run mode: 'build-only' (create/upload artifact), 'run-only' (download/use artifact and run tests), or 'build-and-run' (build in-place then run tests). Defaults to 'build-and-run'."
        default: "build-and-run"
        type: string

  workflow_dispatch:
    inputs:
      project:
        required: false
        description: "The name of the Playwright project to run tests for."
        default: "e2e-electron"
        type: choice
        options:
          - e2e-electron
          - e2e-chromium
          - e2e-firefox
          - e2e-webkit
          - e2e-edge
      grep:
        required: false
        description: "Run tests matching a regular expression. Supports tags, test titles, and filenames. Leave blank to run all tests. For project `e2e-chromium`, tests tagged with @:web are pre-filtered; additional tags, titles, or filenames can be specified to refine filtering."
        default: "@:critical"
        type: string
      repeat_each:
        required: false
        description: "Run each test N times, defaults to one."
        default: 1
        type: number
      skip_extension_test:
        required: false
        description: "Whether to skip the bootstrap extensions test."
        type: boolean
        default: true
      workers:
        required: false
        description: "Number of parallel workers to use, defaults to 2."
        default: 2
        type: number

permissions:
  id-token: write
  contents: read
  packages: read

jobs:
  e2e-linux:
    name: ${{ inputs.display_name || 'e2e-linux' }}
    timeout-minutes: 120
    runs-on: ubuntu-latest-8x
    container:
      image: ghcr.io/posit-dev/positron-ubuntu24-amd64:56
      options: --user 0:0
      # Static PAT is needed because the bot can't pass a token to the job for security reasons
      credentials:
        username: ${{ secrets.POSITRON_GITHUB_RO_USER }}
        password: ${{ secrets.POSITRON_GITHUB_RO_PAT }}
    services:
      postgres:
        image: ghcr.io/posit-dev/positron-postgres-ubuntu24-amd64:56
        credentials:
          username: ${{ secrets.POSITRON_GITHUB_RO_USER }}
          password: ${{ secrets.POSITRON_GITHUB_RO_PAT }}
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: ${{ secrets.E2E_POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.E2E_POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.E2E_POSTGRES_DB }}

    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      DOCKER_CONFIG: /tmp/.docker # Ensure Docker client doesn't try to read a root-owned config file in the container
      POSITRON_BUILD_NUMBER: 0 # CI skips building releases
      _R_CHECK_FUTURE_FILE_TIMESTAMPS_: false # this check can be flaky in the R pkg tests
      _R_CHECK_CRAN_INCOMING_: false
      _R_CHECK_SYSTEM_CLOCK_: false
      AWS_S3_BUCKET: positron-test-reports
      E2E_POSTGRES_USER: ${{ secrets.E2E_POSTGRES_USER }}
      E2E_POSTGRES_PASSWORD: ${{ secrets.E2E_POSTGRES_PASSWORD }}
      E2E_POSTGRES_DB: ${{ secrets.E2E_POSTGRES_DB }}
      E2E_CONNECT_SERVER: ${{ secrets.E2E_CONNECT_SERVER}}
      E2E_CONNECT_APIKEY: ${{ secrets.E2E_CONNECT_APIKEY}}
      R_LIBS_SITE: /usr/local/lib/R/site-library
      R_LIBS_USER: /usr/local/lib/R/site-library
      SNOWFLAKE_ACCOUNT: ${{ secrets.SNOWFLAKE_ACCOUNT }}
      SNOWFLAKE_USER: ${{ secrets.SNOWFLAKE_USER }}
      SNOWFLAKE_PASSWORD: ${{ secrets.SNOWFLAKE_PASSWORD }}
      RETICULATE_PYTHON: /root/.venv/bin/python
      HOME: /root

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Load secret
        uses: 1password/load-secrets-action@v3
        with:
          # Export loaded secrets as environment variables
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          ANTHROPIC_KEY: "op://Positron/Anthropic/credential"

      - name: Transform to Playwright tags $PW_TAGS
        run: bash scripts/pr-tags-transform.sh ${{ inputs.project}} "${{ inputs.grep }}"
        shell: bash

      - name: Ensure Docker config dir is writable
        run: |
          mkdir -p /tmp/.docker
          chmod 700 /tmp/.docker

      - name: Detect Node version
        id: node
        shell: bash
        run: |
          NODE_V=$(node -v || echo "vunknown")
          echo "version=${NODE_V#v}" >> "$GITHUB_OUTPUT"
          echo "Detected Node: ${NODE_V}"

      - name: Restore caches
        id: restore-caches
        if: ${{ inputs.mode != 'run-only' }}
        uses: ./.github/actions/cache-multi-paths
        with:
          node-version: ${{ steps.node.outputs.version }}

      - name: Cache TypeScript build state
        id: cache-tsbuild
        uses: actions/cache@v4
        with:
          path: |
            **/*.tsbuildinfo
            out/**
          key: tsbuild-${{ runner.os }}-node-${{ steps.node.outputs.version }}-${{ hashFiles('**/tsconfig*.json') }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            tsbuild-${{ runner.os }}-node-${{ steps.node.outputs.version }}-
            tsbuild-${{ runner.os }}-

      - name: Attempt 1 - Setup Build and Compile
        id: attempt1
        if: ${{ inputs.mode != 'run-only' }}
        uses: ./.github/actions/setup-build-env
        continue-on-error: true
        with:
          skip-playwright-if-cached: ${{ steps.restore-caches.outputs.cache-playwright-hit }}
          skip-electron-if-cached: ${{ steps.restore-caches.outputs.cache-electron-hit }}
        env:
          NODE_ENV: ${{ env.NODE_ENV }}

      - name: Attempt 2 - Setup Build and Compile
        if: ${{ steps.attempt1.outcome == 'failure' && (inputs.mode != 'run-only') }}
        id: attempt2
        uses: ./.github/actions/setup-build-env
        continue-on-error: true
        with:
          skip-playwright-if-cached: ${{ steps.restore-caches.outputs.cache-playwright-hit }}
          skip-electron-if-cached: ${{ steps.restore-caches.outputs.cache-electron-hit }}

      - name: Attempt 3 - Setup Build and Compile
        id: attempt3
        if: ${{ steps.attempt2.outcome == 'failure' && (inputs.mode != 'run-only') }}
        uses: ./.github/actions/setup-build-env
        with:
          skip-playwright-if-cached: ${{ steps.restore-caches.outputs.cache-playwright-hit }}
          skip-electron-if-cached: ${{ steps.restore-caches.outputs.cache-electron-hit }}

      - name: Fail if Retries Exhausted
        if: ${{ steps.attempt3.outcome == 'failure' && (inputs.mode != 'run-only') }}
        run: exit 1

      - name: Move Positron License
        if: ${{ inputs.install_license && (inputs.mode != 'run-only') }}
        run: |
          mv /positron-license /__w/positron || true
          printf "%s" "${{ secrets.POSITRON_DEV_LICENSE }}" > /__w/positron/positron-license/pdol/target/debug/pdol_rsa || true

      - name: Download build artifact
        if: ${{ inputs.mode == 'run-only' }}
        uses: actions/download-artifact@v4
        with:
          name: "positron-build"
          path: /tmp/artifacts

      - name: Extract build artifact
        if: ${{ inputs.mode == 'run-only' }}
        run: |
          mkdir -p /__w
          # Avoid preserving uid/gid from the tar (can cause permission issues on extract)
          tar --no-same-owner --no-same-permissions -xzf /tmp/artifacts/positron-build.tar.gz -C /__w
          # Ensure extracted files are owned by the runner user so subsequent steps can write to them
          if [ -d /__w/positron ]; then
            chown -R $(id -u):$(id -g) /__w/positron || true
          fi

      - name: Ensure executables are executable
        shell: bash
        if: ${{ inputs.mode == 'run-only' }}
        run: |
          set -euxo pipefail
          chmod +x /__w/positron/scripts/*.sh || true
          chmod +x /__w/positron/bin/* || true
          # if you have a launcher script for Electron:
          test -f /__w/positron/scripts/code.sh && chmod +x /__w/positron/scripts/code.sh || true

      - name: Seed system tmp cache from bundled cache
        if: ${{ inputs.mode == 'run-only' }}
        run: |
          if [ -d /__w/positron/test/e2e/qa-example-content-cache ]; then
            rm -rf /tmp/qa-example-content-cache || true
            cp -R /__w/positron/test/e2e/qa-example-content-cache /tmp/qa-example-content-cache || true
            if [ -f /tmp/qa-example-content-cache/.cached-commit ]; then
              echo "✓ Seeded /tmp/qa-example-content-cache"
            fi
          fi

      - name: Validate bundled QA cache
        if: ${{ inputs.mode == 'run-only' }}
        run: |
          echo "Checking for seeded QA cache at /tmp/qa-example-content-cache/.cached-commit"
          if [ -f /tmp/qa-example-content-cache/.cached-commit ]; then
            echo "✓ Cached commit found: $(cat /tmp/qa-example-content-cache/.cached-commit)"
          else
            echo "✗ Cached commit missing at /tmp/qa-example-content-cache/.cached-commit"
            echo "Contents of /tmp:"; ls -la /tmp || true
            echo "Contents of extracted workspace (/__w/positron/test/e2e):"; ls -la /__w/positron/test/e2e || true
            exit 1
          fi

          # If the install_license input was requested, ensure the license file
          # was included in the artifact and extracted into the workspace.
          if [ "${{ inputs.install_license }}" = "true" ]; then
            LICENSE_PATH="/__w/positron/positron-license/pdol/target/debug/pdol_rsa"
            echo "Checking for Positron license at $LICENSE_PATH"
            if [ -f "$LICENSE_PATH" ]; then
              echo "✓ Positron license present"
            else
              echo "✗ Positron license missing at $LICENSE_PATH"
              echo "Contents of /__w/positron/positron-license (if any):"; ls -la /__w/positron/positron-license || true
              echo "Contents of /__w/positron/test/e2e (for context):"; ls -la /__w/positron/test/e2e || true
              exit 1
            fi
          fi

      - name: Setup E2E Test Environment
        if: ${{ inputs.mode != 'build-only' }}
        uses: ./.github/actions/setup-test-env
        with:
          aws-role-to-assume: ${{ secrets.QA_AWS_RO_ROLE }}
          aws-region: ${{ secrets.QA_AWS_REGION }}

      # Preloading ensures the Node.js binary is fully built and ready before
      # any parallel processes start, preventing runtime conflicts
      - name: Preload Node.js Binary
        if: ${{ inputs.project == 'e2e-chromium' }}
        run: npm run gulp node

      - name: Send Results to GH Summary
        if: ${{ inputs.mode != 'build-only' }}
        uses: ./.github/actions/gen-report-dir

      - name: Alter AppArmor Restrictions for Playwright
        run: sudo sysctl -w kernel.apparmor_restrict_unprivileged_userns=0

      - name: Create Build Artifact
        if: ${{ inputs.mode == 'build-only' }}
        run: |
          # Bundle qa-example-content under positron/test/e2e/qa-example-content-cache
          mkdir -p /__w/positron/test/e2e
          if [ ! -d "/__w/positron/test/e2e/qa-example-content-cache" ]; then
            git clone --depth=1 --branch main https://github.com/posit-dev/qa-example-content.git /__w/positron/test/e2e/qa-example-content-cache || true
          fi

          # Seed cache metadata so the test runner can detect the cached commit
          if [ -d "/__w/positron/test/e2e/qa-example-content-cache" ]; then
            (cd /__w/positron/test/e2e/qa-example-content-cache && git rev-parse HEAD > .cached-commit) || true
          fi

          # Compile E2E tests so compiled outputs are included in the artifact.
          # Use npx to ensure a TypeScript compiler is available without relying
          # on repo-root dev-deps. This keeps the build artifact self-contained.
          if [ -f /__w/positron/test/e2e/package.json ]; then
            echo "Compiling test/e2e for artifact inclusion"
            # Install test deps (production/dev as defined) to populate node_modules used by tests
            npm ci --prefix /__w/positron/test/e2e --prefer-offline --no-audit --no-fund || npm install --prefix /__w/positron/test/e2e --no-audit --no-fund || true
            # Run a local tsc using npx so we don't need typescript listed in the e2e package.json
            npx -y -p typescript tsc -p /__w/positron/test/e2e || true
          fi

          # Fail early if the qa-example-content cache wasn't seeded correctly
          if [ ! -f "/__w/positron/test/e2e/qa-example-content-cache/.cached-commit" ]; then
            echo "Positron QA cache missing .cached-commit at /__w/positron/test/e2e/qa-example-content-cache/.cached-commit"
            echo "Listing /__w/positron/test/e2e for debugging:" || true
            ls -la /__w/positron/test/e2e || true
            exit 1
          fi

          # Create a tarball of the entire positron workspace. Exclude .git to avoid including repository history.
          # If requested, write the Positron license into the workspace
          if [ "${{ inputs.install_license }}" = "true" ]; then
            echo "Installing Positron license into workspace for artifact inclusion"
            mkdir -p /__w/positron/positron-license/pdol/target/debug
            # Write the secret file. Use printf to avoid trailing newline issues.
            printf "%s" "${{ secrets.POSITRON_DEV_LICENSE }}" > /__w/positron/positron-license/pdol/target/debug/pdol_rsa || true
          fi

          # Speed up artifact creation by excluding large, unnecessary directories and
          # using a fast, low-compression streaming gzip pass. This keeps the artifact
          # layout the same for downstream steps while reducing CPU/IO time.
          mkdir -p /tmp/artifacts

          # Collect diagnostics to help decide which files/dirs to exclude from the artifact.
          # This writes a short report with directory sizes and the largest files.
          echo "Collecting artifact diagnostics..." > /tmp/artifacts/build-archive-diagnostics.txt
          if [ -d /__w/positron ]; then
            echo "Total workspace size (KB):" >> /tmp/artifacts/build-archive-diagnostics.txt
            du -sk /__w/positron 2>/dev/null | awk '{print $1 " KB\t" $2}' >> /tmp/artifacts/build-archive-diagnostics.txt || true

            echo "\nTop directories by size (depth=2, KB):" >> /tmp/artifacts/build-archive-diagnostics.txt
            (cd /__w/positron && du -x -k --max-depth=2 . 2>/dev/null | sort -rn | head -n 50) >> /tmp/artifacts/build-archive-diagnostics.txt || true

            echo "\nTop 50 largest files (KB):" >> /tmp/artifacts/build-archive-diagnostics.txt
            # Use find + du to be portable: du -k will report KB per file, then sort
            (cd /__w/positron && find . -type f -exec du -k {} + 2>/dev/null | sort -rn | head -n 50) >> /tmp/artifacts/build-archive-diagnostics.txt || true
          else
            echo "Workspace /__w/positron not found, skipping diagnostics." >> /tmp/artifacts/build-archive-diagnostics.txt
          fi


          # Build a whitelist for the artifact: explicitly include the runtime pieces
          # we expect run-only to need (built Electron, license, test data, scripts,
          # extension runtimes). Also include important native binaries (.node/.wasm)
          # that live in extensions. This yields a much smaller artifact and is safer
          # than excluding by many patterns.
          mkdir -p /tmp/artifacts

          # Base includes (relative to /__w)
          cat > /tmp/artifacts/include-list.txt <<'EOF'
          positron/.build
          positron/out
          positron/resources
          positron/positron-license
          positron/scripts
          positron/bin
          positron/test
          # Explicitly include compiled E2E test outputs and metadata
          positron/test/e2e/out
          positron/test/e2e/package-lock.json
          # Include installed runtime dependencies to avoid any installs in run-only
          positron/test/e2e/node_modules
          # Include TypeScript runtime required by some test compile steps
          positron/node_modules/typescript
          EOF

          # Add per-extension out/dist/resources folders if present and collect
          # important native/runtime files (.node, .wasm, copilot-language-server, vsce-sign, ark, kallichore)
          cd /__w/positron || true
          for e in extensions/*; do
            if [ -d "$e/out" ]; then
              echo "positron/$e/out" >> /tmp/artifacts/include-list.txt
            fi
            if [ -d "$e/dist" ]; then
              echo "positron/$e/dist" >> /tmp/artifacts/include-list.txt
            fi
            if [ -d "$e/resources" ]; then
              echo "positron/$e/resources" >> /tmp/artifacts/include-list.txt
            fi
          done

          # Collect important native/runtime files under extensions (record as relative paths)
          find . -path './extensions/*' -type f \( -iname '*.node' -o -iname '*.wasm' -o -iname 'copilot-language-server*' -o -iname 'vsce-sign*' -o -iname 'ark' -o -iname 'kallichore*' \) -print | sed 's|^./|positron/|' >> /tmp/artifacts/include-list.txt || true

          # Deduplicate and filter out any blank lines
          awk 'NF' /tmp/artifacts/include-list.txt | sort -u > /tmp/artifacts/include-list.txt.sorted || true
          mv /tmp/artifacts/include-list.txt.sorted /tmp/artifacts/include-list.txt || true

          # Create tar from whitelist and compress with gzip level 1 (fast).
          # Filter the include list to existing paths so tar doesn't fail when a
          # listed path is absent in this particular build. Record missing paths
          # for diagnostics.
          /bin/echo "Filtering include list for existing paths..." >> /tmp/artifacts/build-archive-diagnostics.txt || true
          rm -f /tmp/artifacts/include-list.present.txt /tmp/artifacts/include-list.missing.txt || true
          # Trim leading/trailing whitespace from include-list entries before testing
          while IFS= read -r p || [ -n "$p" ]; do
            # Trim leading/trailing whitespace
            p_trimmed=$(printf "%s" "$p" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            # Skip blank lines after trimming
            [ -z "$p_trimmed" ] && continue
            if [ -e "/__w/$p_trimmed" ]; then
              echo "$p_trimmed" >> /tmp/artifacts/include-list.present.txt
            else
              echo "$p_trimmed" >> /tmp/artifacts/include-list.missing.txt
            fi
          done < /tmp/artifacts/include-list.txt || true

          if [ -f /tmp/artifacts/include-list.missing.txt ]; then
            echo "\nMissing include-list entries (may be normal):" >> /tmp/artifacts/build-archive-diagnostics.txt || true
            sed -n '1,200p' /tmp/artifacts/include-list.missing.txt >> /tmp/artifacts/build-archive-diagnostics.txt || true
          fi

          if [ -s /tmp/artifacts/include-list.present.txt ]; then
            tar -C /__w -T /tmp/artifacts/include-list.present.txt -cf - | gzip -1 > /tmp/artifacts/positron-build.tar.gz || true
          else
            echo "No files matched include-list; producing empty tar.gz" >> /tmp/artifacts/build-archive-diagnostics.txt || true
            # produce an empty tar.gz to keep downstream steps stable
            (tar -C /tmp -cf - --files-from /dev/null) | gzip -1 > /tmp/artifacts/positron-build.tar.gz || true
          fi

      - name: Upload Build Artifact
        if: ${{ inputs.mode == 'build-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: "positron-build"
          path: /tmp/artifacts/positron-build.tar.gz
          retention-days: 1
          compression-level: 1

      - name: Upload Build Diagnostics
        if: ${{ inputs.mode == 'build-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: "positron-build-diagnostics"
          path: /tmp/artifacts/build-archive-diagnostics.txt
          if-no-files-found: ignore

      - name: Install Playwright browsers
        if: ${{ inputs.mode != 'build-only' && !(inputs.project == 'e2e-electron' || inputs.project == 'e2e-chromium') && steps.restore-caches.outputs.cache-playwright-hit != 'true' }}
        run: |
          echo "Installing default Playwright browser binaries into $HOME/.cache/ms-playwright"
          npx playwright install --with-deps
          # Edge is NOT installed by the default installer; add it explicitly for the e2e-edge project.
          if [ "${{ inputs.project }}" = "e2e-edge" ]; then
            echo "Installing Microsoft Edge browser channel for Playwright (msedge)"
            npx playwright install msedge
          fi

      - name: Run Playwright Tests
        if: ${{ inputs.mode != 'build-only' }}
        shell: bash
        env:
          POSITRON_PY_VER_SEL: "3.10.12"
          POSITRON_R_VER_SEL: 4.4.0
          POSITRON_PY_ALT_VER_SEL: "3.13.0"
          POSITRON_R_ALT_VER_SEL: 4.4.2
          POSITRON_HIDDEN_PY: "3.12.10 (Conda)"
          POSITRON_HIDDEN_R: 4.4.1
          CURRENTS_RECORD_KEY: ${{ secrets.CURRENTS_RECORD_KEY }}
          CURRENTS_CI_BUILD_ID: ${{ github.run_id }}-${{ github.run_attempt }}
          COMMIT_INFO_MESSAGE: ${{ github.event.head_commit.message }}
          PWTEST_BLOB_DO_NOT_REMOVE: 1
          CURRENTS_TAG: ${{ inputs.currents_tags || 'electron/ubuntu' }}
          ENABLE_CURRENTS_REPORTER: ${{ inputs.report_currents }}
          CURRENTS_PROJECT_ID: ${{ vars.CURRENTS_PROJECT_ID}}
          CONNECT_API_KEY: ${{ secrets.CONNECT_API_KEY }}
          USE_KEY: true
          PW_JSON_FILE: test-results/ubuntu.json
          ALLOW_SOFT_FAIL: ${{ inputs.allow_soft_fail }}
        run: |
          # Build the --grep argument only if PW_TAGS is non-empty
          if [ -z "${{ env.PW_TAGS }}" ]; then
            GREP_ARG=""
          else
            GREP_ARG="--grep \"${{ env.PW_TAGS }}\""
          fi

          # Log the arguments
          echo "Final --grep argument: $GREP_ARG"

          # Don't run this test in parallel & don't allow skipping it
          if [ "${{ inputs.skip_extension_test }}" != "true" ]; then
            echo "Running: npx playwright test test/e2e/tests/extensions/bootstrap-extensions.test.ts --project ${{ inputs.project }} --reporter=null"
            npx playwright test test/e2e/tests/extensions/bootstrap-extensions.test.ts --project ${{ inputs.project }} --reporter=null
            SKIP_CLONE_ARG="SKIP_CLONE=true"
          else
            echo "Skipping bootstrap extensions test (skip_extension_test=true)"
            SKIP_CLONE_ARG=""
          fi

          # Run the Playwright test command directly using eval
          echo "Running: npx playwright test --project ${{ inputs.project }} --workers ${{ inputs.workers }} $GREP_ARG --repeat-each ${{ inputs.repeat_each }} --max-failures 10"

          if [[ "$ALLOW_SOFT_FAIL" == "true" ]]; then
            eval SKIP_BOOTSTRAP=true $SKIP_CLONE_ARG npx playwright test --project ${{ inputs.project }} --workers ${{ inputs.workers }} $GREP_ARG --repeat-each ${{ inputs.repeat_each }} --max-failures 10 || true

            node ./scripts/check-soft-fail-failures.js "${PW_JSON_FILE}"
          else
            eval SKIP_BOOTSTRAP=true $SKIP_CLONE_ARG npx playwright test --project ${{ inputs.project }} --workers ${{ inputs.workers }} $GREP_ARG --repeat-each ${{ inputs.repeat_each }} --max-failures 10
          fi

      - name: Upload Playwright Report to S3
        if: ${{ success() || failure() }}
        uses: ./.github/actions/upload-report-to-s3
        with:
          role-to-assume: ${{ secrets.AWS_TEST_REPORTS_ROLE }}
          report-dir: ${{ env.REPORT_DIR }}

      - name: Upload Test Logs
        if: ${{ always() && inputs.upload_logs }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.project }}-logs
          path: test-logs
          if-no-files-found: ignore

      - name: Upload Test Results File
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.project }}-ubuntu-json-results
          path: test-results/ubuntu.json
          if-no-files-found: ignore

      - name: Upload inspect-ai JSON Responses
        if: ${{ always() && inputs.project == 'inspect-ai' }}
        uses: actions/upload-artifact@v4
        with:
          name: inspect-ai-responses
          path: test/assistant-inspect-ai/*.json
