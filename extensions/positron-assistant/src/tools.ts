/*---------------------------------------------------------------------------------------------
 *  Copyright (C) 2024-2025 Posit Software, PBC. All rights reserved.
 *  Licensed under the Elastic License 2.0. See LICENSE.txt for license information.
 *--------------------------------------------------------------------------------------------*/

import * as vscode from 'vscode';
import * as positron from 'positron';
import * as ai from 'ai';

import { z } from 'zod';
import { padBase64String } from './utils';

export interface PositronToolAdapter {
	name: string;
	description: string;
	lmTool: vscode.LanguageModelChatTool;
	aiTool(token: unknown, toolOptions: unknown): ai.CoreTool;
}

export const getPlotToolAdapter: PositronToolAdapter = {
	name: 'getPlot',
	description: 'Get the current visible plot.',

	get lmTool() {
		return {
			name: this.name,
			description: this.description,
		};
	},

	aiTool(token: unknown): ai.CoreTool {
		const push = (part: vscode.ChatResponsePart) => positron.ai.responseProgress(token, part);
		return ai.tool({
			description: this.description,
			parameters: z.object({}),
			execute: async () => {
				push(new vscode.ChatResponseProgressPart('Getting the current plot...'));
				const uri = await positron.ai.getCurrentPlotUri();
				const matches = uri?.match(/^data:([^;]+);base64,(.+)$/);
				if (!matches || !uri) {
					return 'No plot visible';
				}

				push(new vscode.ChatResponseProgressPart('Analysing the plot image data...'));
				return {
					type: 'image' as const,
					mimeType: matches[1],
					data: padBase64String(matches[2]),
				};
			},
			experimental_toToolResultContent(result) {
				return typeof result === 'string'
					? [{ type: 'text', text: result }]
					: [result];
			},
		});
	}
};


export const executeToolAdapter: PositronToolAdapter = {
	name: 'execute',
	description: 'Execute code in the active console. The result will be silently returned.',

	get lmTool() {
		return {
			name: this.name,
			description: this.description,
		};
	},

	aiTool(token: unknown): ai.CoreTool {
		const push = (part: vscode.ChatResponsePart) => positron.ai.responseProgress(token, part);
		return ai.tool({
			description: this.description,
			parameters: z.object({
				code: z.string().describe('Code to execute.'),
			}),
			execute: async ({ code }) => {
				if (!code.trim()) {
					return null;
				}

				push(new vscode.ChatResponseProgressPart('Executing code...'));
				const session = await positron.runtime.getForegroundSession();
				if (!session || !session.callMethod) {
					return null;
				}

				push(new vscode.ChatResponseMarkdownPart(
					`\n\n\`\`\`${session.runtimeMetadata.languageId}\n${code}\n\`\`\`\n\n`
				));

				// TODO: This is a hack so that we can execute code generated by an LLM and return
				// the resulting output. The functionality should instead be formalised as a comm.
				if (session.runtimeMetadata.languageId === 'r') {
					await positron.runtime.executeCode(session.runtimeMetadata.languageId, `
						if (!exists(".ps.rpc.evaluate")) {
							.GlobalEnv$.ps.rpc.evaluate <- function(code) {
								.GlobalEnv$.last_result <- evaluate::evaluate(code)
								capture.output(.GlobalEnv$.last_result)
							}
						}
					`, false, false, positron.RuntimeCodeExecutionMode.Silent);

					try {
						const result = await session.callMethod('evaluate', code);
						return result;
					} catch (_e) {
						const e = _e as Error;
						return e.message;
					} finally {
						session.execute(
							'evaluate::replay(.GlobalEnv$.last_result)',
							session.runtimeMetadata.languageId,
							positron.RuntimeCodeExecutionMode.Transient,
							positron.RuntimeErrorBehavior.Continue
						);
					}
				} else if (session.runtimeMetadata.languageId === 'python') {
					try {
						const result = await session.callMethod('evaluate', code);
						return result;
					} catch (_e) {
						const e = _e as Error;
						return e.message;
					}
				} else {
					session.execute(
						code,
						session.runtimeMetadata.languageId,
						positron.RuntimeCodeExecutionMode.Transient,
						positron.RuntimeErrorBehavior.Continue
					);
					return true;
				}
			},
		});
	},
};


export const textEditToolAdapter: PositronToolAdapter = {
	name: 'textEdit',
	description: 'Output an edited version of the code selection.',

	get lmTool() {
		return {
			name: this.name,
			description: this.description,
		};
	},

	aiTool(token: unknown, options: { document: vscode.TextDocument; selection: vscode.Selection }): ai.CoreTool {
		const push = (part: vscode.ChatResponseTextEditPart) => positron.ai.responseProgress(token, part);

		return ai.tool({
			description: this.description,
			parameters: z.object({
				code: z.string().describe('The entire edited code selection.'),
			}),
			execute: async ({ code }) => {
				push(new vscode.ChatResponseTextEditPart(
					options.document.uri,
					vscode.TextEdit.replace(options.selection, code)
				));
			},
		});
	}
};

export const positronToolAdapters: Record<string, PositronToolAdapter> = {
	[getPlotToolAdapter.name]: getPlotToolAdapter,
	[executeToolAdapter.name]: executeToolAdapter,
	[textEditToolAdapter.name]: textEditToolAdapter,
};

