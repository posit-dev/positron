/*---------------------------------------------------------------------------------------------
 *  Copyright (C) 2024-2025 Posit Software, PBC. All rights reserved.
 *  Licensed under the Elastic License 2.0. See LICENSE.txt for license information.
 *--------------------------------------------------------------------------------------------*/

import * as vscode from 'vscode';
import * as positron from 'positron';

import { getContext } from './context';

const CONSENT_KEY = 'positron-assistant.executeCodeConsent';
const CONSENT_DURATION_MS = 60 * 60 * 1000;

async function checkExecuteConsent(token: unknown): Promise<boolean> {
	const context = getContext();
	const lastConsent = context.globalState.get<number>(CONSENT_KEY);
	const now = Date.now();

	if (lastConsent && (now - lastConsent) < CONSENT_DURATION_MS) {
		return true;
	}

	positron.ai.responseProgress(token, new vscode.ChatResponseProgressPart('Asking for user consent to execute code...'));

	const result = await vscode.window.showInformationMessage(
		'Positron Assistant is about to execute code in your active console.\n\n AI-generated code may contain errors or unexpected behavior.',
		{ modal: true },
		'Allow',
	);

	if (result === 'Allow') {
		await context.globalState.update(CONSENT_KEY, now);
		return true;
	}

	return false;
}

export async function executeCodeInActiveConsole(code: string, token: unknown) {

	function push(part: vscode.ChatResponsePart | vscode.ChatResponseConfirmationPart) {
		return positron.ai.responseProgress(token, part);
	}

	if (!code.trim()) {
		return null;
	}

	const session = await positron.runtime.getForegroundSession();
	if (!session || !session.callMethod) {
		return null;
	}

	push(new vscode.ChatResponseMarkdownPart(
		`\n\n\`\`\`${session.runtimeMetadata.languageId}\n${code}\n\`\`\`\n\n`
	));

	// Ask user if we can go ahead and execute code.
	const userConsent = await checkExecuteConsent(token);
	if (!userConsent) {
		return 'Error: The user denied the request to execute code.';
	}

	push(new vscode.ChatResponseProgressPart('Executing code...'));

	// TODO: This is a hack so that we can execute code generated by an LLM and return
	// the resulting output. The functionality should instead be formalised as a comm.
	if (session.runtimeMetadata.languageId === 'r') {
		await positron.runtime.executeCode(session.runtimeMetadata.languageId, `
						if (!exists(".ps.rpc.evaluate")) {
							.GlobalEnv$.ps.rpc.evaluate <- function(code) {
								.GlobalEnv$.last_result <- evaluate::evaluate(code)
								capture.output(.GlobalEnv$.last_result)
							}
						}
					`, false, false, positron.RuntimeCodeExecutionMode.Silent);

		try {
			const result = await session.callMethod('evaluate', code);
			return result;
		} catch (_e) {
			const e = _e as Error;
			return e.message;
		} finally {
			session.execute(
				'evaluate::replay(.GlobalEnv$.last_result)',
				session.runtimeMetadata.languageId,
				positron.RuntimeCodeExecutionMode.Transient,
				positron.RuntimeErrorBehavior.Continue
			);
		}
	} else if (session.runtimeMetadata.languageId === 'python') {
		try {
			const result = await session.callMethod('evaluate', code);
			return result;
		} catch (_e) {
			const e = _e as Error;
			return e.message;
		}
	} else {
		session.execute(
			code,
			session.runtimeMetadata.languageId,
			positron.RuntimeCodeExecutionMode.Transient,
			positron.RuntimeErrorBehavior.Continue
		);
		return true;
	}
}
