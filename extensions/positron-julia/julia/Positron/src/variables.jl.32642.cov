        - # ---------------------------------------------------------------------------------------------
        - # Copyright (C) 2024-2025 Posit Software, PBC. All rights reserved.
        - # Licensed under the Elastic License 2.0. See LICENSE.txt for license information.
        - # ---------------------------------------------------------------------------------------------
        - 
        - """
        - Variables service for Positron.
        - 
        - This module provides the Variables pane functionality, allowing users to browse
        - and inspect variables in the Julia session.
        - """
        - 
        - # Note: Param types are now properly prefixed (VariablesUpdateParams, VariablesRefreshParams)
        - # to avoid naming conflicts with other comm files
        - 
        - """
        - The Variables service manages the Variables pane in Positron.
        - """
        - mutable struct VariablesService
        - 	comm::Any  # PositronComm or test mock - using Any for testability
        - 	current_version::Int
        - 	last_snapshot::Dict{String,Any}  # Maps variable name to Variable
        - 
        4 	function VariablesService()
        4 		new(nothing, 0, Dict{String,Any}())
        - 	end
        - end
        - 
        - """
        - Initialize the variables service with a comm.
        - """
        - function init!(service::VariablesService, comm::PositronComm)
        - 	service.comm = comm
        - 
        - 	on_msg!(comm, msg -> handle_variables_msg(service, msg))
        - 	on_close!(comm, () -> handle_variables_close(service))
        - end
        - 
        - """
        - Handle incoming messages on the variables comm.
        - """
        - function handle_variables_msg(service::VariablesService, msg::Dict)
        - 	request = parse_variables_request(msg)
        - 
        - 	if request === nothing
        - 		# list request
        - 		handle_list(service)
        - 	elseif request isa VariablesClearParams
        - 		handle_clear(service, request.include_hidden_objects)
        - 	elseif request isa VariablesDeleteParams
        - 		handle_delete(service, request.names)
        - 	elseif request isa VariablesInspectParams
        - 		handle_inspect(service, request.path)
        - 	elseif request isa VariablesClipboardFormatParams
        - 		handle_clipboard_format(service, request.path, request.format)
        - 	elseif request isa VariablesViewParams
        - 		handle_view(service, request.path)
        - 	end
        - end
        - 
        - """
        - Handle variables comm close.
        - """
        - function handle_variables_close(service::VariablesService)
        - 	service.comm = nothing
        - end
        - 
        - """
        - Handle list request - return all variables in Main.
        - """
        1 function handle_list(service::VariablesService)
        1 	variables = collect_variables()
        1 	service.current_version += 1
        1 	service.last_snapshot = Dict(v.display_name => v for v in variables)
        - 
        1 	result = VariableList(variables, length(variables), service.current_version)
        1 	send_result(service.comm, result)
        - end
        - 
        - """
        - Handle clear request - clear all user-defined variables.
        - """
        - function handle_clear(service::VariablesService, include_hidden::Bool)
        - 	# Get all names in Main
        - 	for name in names(Main; all=include_hidden)
        - 		# Skip special names and modules
        - 		if should_skip_variable(name)
        - 			continue
        - 		end
        - 		try
        - 			# Note: In Julia, we can't truly delete variables, but we can set them to nothing
        - 			# or remove them from the workspace. For now, we'll skip this functionality
        - 			# as it's complex to implement safely.
        - 		catch e
        - 			@warn "Failed to clear variable" name exception=e
        - 		end
        - 	end
        - 
        - 	# Send updated variable list
        - 	handle_list(service)
        - end
        - 
        - """
        - Handle delete request - delete specific variables.
        - """
        - function handle_delete(service::VariablesService, var_names::Vector{String})
        - 	# Similar to clear, this is complex in Julia
        - 	# For now, we acknowledge the request and send updated list
        - 	handle_list(service)
        - end
        - 
        - """
        - Handle inspect request - return children of a variable.
        - """
        - function handle_inspect(service::VariablesService, path::Vector{String})
        - 	if isempty(path)
        - 		send_error(service.comm, JsonRpcErrorCode.INVALID_PARAMS, "Empty path")
        - 		return
        - 	end
        - 
        - 	# Navigate to the value
        - 	value = get_value_at_path(path)
        - 	if value === nothing
        - 		send_error(service.comm, JsonRpcErrorCode.INVALID_PARAMS, "Variable not found")
        - 		return
        - 	end
        - 
        - 	# Get children
        - 	children = get_children(value)
        - 	result = InspectedVariable(children, length(children))
        - 	send_result(service.comm, result)
        - end
        - 
        - """
        - Handle clipboard format request - format variable for clipboard.
        - """
        - function handle_clipboard_format(service::VariablesService, path::Vector{String}, format::String)
        - 	if isempty(path)
        - 		send_error(service.comm, JsonRpcErrorCode.INVALID_PARAMS, "Empty path")
        - 		return
        - 	end
        - 
        - 	value = get_value_at_path(path)
        - 	if value === nothing
        - 		send_error(service.comm, JsonRpcErrorCode.INVALID_PARAMS, "Variable not found")
        - 		return
        - 	end
        - 
        - 	# Format the value
        - 	content = format_for_clipboard(value, format)
        - 	result = FormattedVariable(content)
        - 	send_result(service.comm, result)
        - end
        - 
        - """
        - Handle view request - open data viewer for variable.
        - """
        - function handle_view(service::VariablesService, path::Vector{String})
        - 	if isempty(path)
        - 		send_error(service.comm, JsonRpcErrorCode.INVALID_PARAMS, "Empty path")
        - 		return
        - 	end
        - 
        - 	# TODO: Open data explorer for the variable
        - 	# For now, just acknowledge
        - 	send_result(service.comm, nothing)
        - end
        - 
        - """
        - Collect all visible variables from Main module.
        - """
        4 function collect_variables()::Vector{Variable}
        4 	variables = Variable[]
        4 	current_time = round(Int, time() * 1000)
        - 
        4 	for name in names(Main; all=false)
       90 		if should_skip_variable(name)
       16 			continue
        - 		end
        - 
       74 		try
       74 			value = getfield(Main, name)
       74 			var = create_variable(string(name), value, current_time)
       74 			push!(variables, var)
        - 		catch e
        0 			@debug "Failed to collect variable" name exception=e
        - 		end
       90 	end
        - 
        4 	return variables
        - end
        - 
        - """
        - Check if a variable should be skipped (internal, special, etc).
        - """
       98 function should_skip_variable(name::Symbol)::Bool
       98 	name_str = string(name)
        - 
        - 	# Skip internal Julia names
      195 	if startswith(name_str, "#") || startswith(name_str, "_")
        6 		return true
        - 	end
        - 
        - 	# Skip certain well-known names
       92 	if name in (:Base, :Core, :Main, :ans, :include, :eval)
       16 		return true
        - 	end
        - 
        - 	# Skip modules (they're not user variables)
       76 	try
       76 		val = getfield(Main, name)
       76 		if val isa Module
        0 			return true
        - 		end
        - 	catch
        0 		return true
        - 	end
        - 
       76 	return false
        - end
        - 
        - """
        - Create a Variable struct for a value.
        - """
      190 function create_variable(name::String, value::Any, timestamp::Int)::Variable
      332 	kind = get_variable_kind(value)
      312 	display_value = get_display_value(value)
      312 	display_type = get_display_type(value)
      312 	type_info = string(typeof(value))
      312 	len = get_variable_length(value)
      312 	sz = get_variable_size(value)
      312 	has_children = value_has_children(value)
      497 	has_viewer = value_has_viewer(value)
      312 	is_truncated = length(display_value) >= 1000
        - 
        - 	# Field order matches generated Variable struct:
        - 	# access_key, display_name, display_value, display_type, type_info,
        - 	# size, kind, length, has_children, has_viewer, is_truncated, updated_time
      312 	Variable(
        - 		name,           # access_key
        - 		name,           # display_name
        - 		display_value,
        - 		display_type,
        - 		type_info,
        - 		sz,             # size
        - 		kind,           # kind
        - 		len,            # length
        - 		has_children,
        - 		has_viewer,
        - 		is_truncated,
        - 		timestamp       # updated_time
        - 	)
        - end
        - 
        - """
        - Determine the VariableKind for a value.
        - """
       69 function get_variable_kind(value::Any)::VariableKind
      381 	if value isa Bool
        4 		return VariableKind_Boolean
      377 	elseif value isa Number
      260 		return VariableKind_Number
      117 	elseif value isa AbstractString
       13 		return VariableKind_String
      104 	elseif value isa Function
       25 		return VariableKind_Function
       79 	elseif value isa AbstractDict
       13 		return VariableKind_Map
       66 	elseif value isa AbstractArray
       18 		return VariableKind_Collection
       48 	elseif value === nothing || value === missing
        4 		return VariableKind_Empty
       44 	elseif is_table_like(value)
        7 		return VariableKind_Table
       37 	elseif value isa Type
       26 		return VariableKind_Class
        - 	else
       11 		return VariableKind_Other
        - 	end
        - end
        - 
        - """
        - Check if a value is table-like (DataFrames, etc).
        - """
      412 function is_table_like(value::Any)::Bool
        - 	# Check for Tables.jl interface
      713 	try
        - 		# Try to use Tables.istable if available
      713 		if isdefined(Main, :Tables) && isdefined(Main.Tables, :istable)
      307 			return Main.Tables.istable(value)
        - 		end
        0 	catch
        - 	end
        - 
        - 	# Check for common table types by name
      406 	type_name = string(typeof(value))
      406 	return occursin("DataFrame", type_name) ||
        - 		   occursin("Table", type_name) ||
        - 		   occursin("Matrix", type_name)
        - end
        - 
        - """
        - Get the display value for a variable.
        - 
        - For DataFrames, shows dimensions like "[5 rows x 3 columns] DataFrame".
        - """
      344 function get_display_value(value::Any)::String
        - 	# Special handling for DataFrames
      344 	if isdefined(Main, :DataFrames) && value isa Main.DataFrames.DataFrame
        0 		try
        0 			rows = Main.DataFrames.nrow(value)
        0 			cols = Main.DataFrames.ncol(value)
        0 			return "[$rows rows x $cols columns] DataFrame"
        0 		catch
        - 		end
        - 	end
        - 
        - 	# Default display
      344 	try
      344 		io = IOBuffer()
      370 		show(IOContext(io, :compact => true, :limit => true), value)
      688 		str = String(take!(io))
        - 		# Truncate if too long
      344 		if length(str) > 1000
        2 			return str[1:1000] * "..."
        - 		end
      342 		return str
        - 	catch e
        0 		return "<error displaying value>"
        - 	end
        - end
        - 
        - """
        - Get the display type for a variable.
        - 
        - For DataFrames, shows dimensions like "DataFrame [5x3]".
        - """
      333 function get_display_type(value::Any)::String
        - 	# Special handling for DataFrames
      333 	if isdefined(Main, :DataFrames) && value isa Main.DataFrames.DataFrame
        0 		try
        0 			rows = Main.DataFrames.nrow(value)
        0 			cols = Main.DataFrames.ncol(value)
        0 			return "DataFrame [$rows x $cols]"
        0 		catch
        - 		end
        - 	end
        - 
      333 	T = typeof(value)
        - 
        - 	# Simplify common type names
      333 	if T <: AbstractVector
       10 		eltype_str = string(eltype(value))
       10 		return "Vector{$eltype_str}"
      323 	elseif T <: AbstractMatrix
        2 		eltype_str = string(eltype(value))
        2 		return "Matrix{$eltype_str}"
      321 	elseif T <: AbstractDict
       10 		return "Dict"
        - 	else
      311 		type_str = string(T)
        - 		# Truncate long type names
      311 		if length(type_str) > 50
        1 			return type_str[1:50] * "..."
        - 		end
      310 		return type_str
        - 	end
        - end
        - 
        - """
        - Get the length of a variable (for collections).
        - 
        - For DataFrames, returns the number of rows (nrow).
        - For other collections, returns length().
        - """
      219 function get_variable_length(value::Any)::Int
        - 	# Handle DataFrames specially - use nrow()
      341 	if is_table_like(value)
        7 		try
        - 			# Try to get row count via Tables.jl interface or nrow
        7 			if isdefined(Main, :DataFrames) && value isa Main.DataFrames.DataFrame
        7 				return Main.DataFrames.nrow(value)
        0 			elseif isdefined(Main, :Tables) && isdefined(Main.Tables, :rowcount)
        0 				rc = Main.Tables.rowcount(value)
        0 				return rc === nothing ? 0 : rc
        - 			end
        0 		catch
        - 		end
        - 	end
        - 
        - 	# For other types, use length()
      334 	try
      334 		return length(value)
        - 	catch
       45 		return 0
        - 	end
        - end
        - 
        - """
        - Get the size in bytes of a variable.
        - """
      325 function get_variable_size(value::Any)::Int64
      325 	try
      325 		return Int64(Base.summarysize(value))
        - 	catch
        0 		return Int64(0)
        - 	end
        - end
        - 
        - """
        - Check if a value has children that can be inspected.
        - """
       32 function value_has_children(value::Any)::Bool
      344 	if value isa AbstractDict || value isa AbstractArray
       23 		return !isempty(value)
      321 	elseif value isa Number || value isa AbstractString || value isa Bool
      261 		return false
       60 	elseif value === nothing || value === missing
        4 		return false
       56 	elseif value isa Function
       22 		return false
        - 	else
        - 		# Struct-like types have fields
       34 		return fieldcount(typeof(value)) > 0
        - 	end
        - end
        - 
        - """
        - Check if a value can be viewed in the data explorer.
        - """
       10 function value_has_viewer(value::Any)::Bool
        - 	# Tables and matrices can be viewed
      511 	if is_table_like(value) || value isa AbstractMatrix
        6 		return true
        - 	end
        - 
        - 	# Large vectors could potentially be viewed
      316 	if value isa AbstractVector && length(value) > 10
        1 		return true
        - 	end
        - 
      315 	return false
        - end
        - 
        - """
        - Get the value at a given path.
        - """
        8 function get_value_at_path(path::Vector{String})
        8 	if isempty(path)
        0 		return nothing
        - 	end
        - 
        - 	# Start from Main
        8 	try
        8 		current = getfield(Main, Symbol(path[1]))
        - 
        7 		for key in path[2:end]
       10 			current = get_child_value(current, key)
       10 			if current === nothing
        1 				return nothing
        - 			end
        9 		end
        - 
        7 		return current
        - 	catch e
        1 		@debug "Failed to get value at path" path exception=e
        1 		return nothing
        - 	end
        - end
        - 
        - """
        - Get a child value from a parent.
        - """
       22 function get_child_value(parent::Any, key::String)
        - 	# Try dictionary access
       22 	if parent isa AbstractDict
        - 		# Try string key first
       20 		if haskey(parent, key)
        8 			return parent[key]
        - 		end
        - 		# Try symbol key
        5 		if haskey(parent, Symbol(key))
        1 			return parent[Symbol(key)]
        - 		end
        - 		# Try integer key
        6 		idx = tryparse(Int, key)
        3 		if idx !== nothing && haskey(parent, idx)
        1 			return parent[idx]
        - 		end
        - 	end
        - 
        - 	# Try array access
       12 	if parent isa AbstractArray
       14 		idx = tryparse(Int, key)
        7 		if idx !== nothing && checkbounds(Bool, parent, idx)
        5 			return parent[idx]
        - 		end
        - 	end
        - 
        - 	# Try field access
        7 	sym = Symbol(key)
        7 	if hasfield(typeof(parent), sym)
        2 		return getfield(parent, sym)
        - 	end
        - 
        5 	return nothing
        - end
        - 
        - """
        - Get children of a value for inspection.
        - """
       18 function get_children(value::Any)::Vector{Variable}
       18 	children = Variable[]
       18 	current_time = round(Int, time() * 1000)
        - 
       18 	if value isa AbstractDict
        4 		for (k, v) in value
        6 			key_str = string(k)
        6 			push!(children, create_variable(key_str, v, current_time))
       10 		end
       16 	elseif value isa AbstractArray
        - 		# Limit number of children shown
        6 		n = min(length(value), 100)
        6 		for i in 1:n
      219 			push!(children, create_variable("[$i]", value[i], current_time))
      432 		end
        - 	else
        - 		# Get fields
       10 		for field in fieldnames(typeof(value))
       10 			try
       10 				field_value = getfield(value, field)
       10 				push!(children, create_variable(string(field), field_value, current_time))
        0 			catch
        - 			end
       14 		end
        - 	end
        - 
       18 	return children
        - end
        - 
        - """
        - Format a value for clipboard.
        - """
        2 function format_for_clipboard(value::Any, format::String)::String
        2 	if format == "text/plain"
        1 		io = IOBuffer()
        1 		show(IOContext(io, :limit => false), MIME("text/plain"), value)
        1 		return String(take!(io))
        - 	else
        1 		return repr(value)
        - 	end
        - end
        - 
        - """
        - Send a refresh event to the frontend.
        - """
        1 function send_refresh!(service::VariablesService)
        1 	if service.comm === nothing
        0 		return
        - 	end
        - 
        1 	variables = collect_variables()
        1 	service.current_version += 1
        1 	service.last_snapshot = Dict(v.display_name => v for v in variables)
        - 
        1 	params = VariablesRefreshParams(variables, length(variables), service.current_version)
        1 	send_event(service.comm, "refresh", params)
        - end
        - 
        - """
        - Send an update event to the frontend with changes.
        - """
        1 function send_update!(service::VariablesService)
        1 	if service.comm === nothing
        0 		return
        - 	end
        - 
        - 	# Compute diff from last snapshot
        1 	current_vars = collect_variables()
        1 	current_map = Dict(v.display_name => v for v in current_vars)
        - 
        1 	assigned = Variable[]
        1 	removed = String[]
        - 
        - 	# Find new or changed variables
        1 	for var in current_vars
       19 		if !haskey(service.last_snapshot, var.display_name)
       19 			push!(assigned, var)
        0 		elseif service.last_snapshot[var.display_name].display_value != var.display_value
        0 			push!(assigned, var)
        - 		end
       19 	end
        - 
        - 	# Find removed variables
        2 	for name in keys(service.last_snapshot)
        0 		if !haskey(current_map, name)
        0 			push!(removed, name)
        - 		end
        0 	end
        - 
        - 	# Only send if there are changes
        1 	if !isempty(assigned) || !isempty(removed)
        1 		service.current_version += 1
        1 		service.last_snapshot = current_map
        - 
        1 		params = VariablesUpdateParams(assigned, Variable[], removed, service.current_version)
        1 		send_event(service.comm, "update", params)
        - 	end
        - end
